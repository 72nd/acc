// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// GetCustomersParams defines parameters for GetCustomers.
type GetCustomersParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching customers.
	Query *string `json:"query,omitempty"`

	// Search for customers with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// PostCustomersIdJSONBody defines parameters for PostCustomersId.
type PostCustomersIdJSONBody struct {

	// Unique user-chosen identifier for a Party, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the person/company
	Name *string `json:"name,omitempty"`

	// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
	PartyType *int `json:"partyType,omitempty"`

	// Name of the place
	Place *string `json:"place,omitempty"`

	// ZIP/Postal-Code of the address
	PostalCode *int `json:"postalCode,omitempty"`

	// Name of the street the party residence in
	Street *string `json:"street,omitempty"`

	// Street number of party's address
	StreetNr *int `json:"streetNr,omitempty"`
}

// PutCustomersIdJSONBody defines parameters for PutCustomersId.
type PutCustomersIdJSONBody struct {

	// Unique user-chosen identifier for a Party, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the person/company
	Name *string `json:"name,omitempty"`

	// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
	PartyType *int `json:"partyType,omitempty"`

	// Name of the place
	Place *string `json:"place,omitempty"`

	// ZIP/Postal-Code of the address
	PostalCode *int `json:"postalCode,omitempty"`

	// Name of the street the party residence in
	Street *string `json:"street,omitempty"`

	// Street number of party's address
	StreetNr *int `json:"streetNr,omitempty"`
}

// GetEmployeesParams defines parameters for GetEmployees.
type GetEmployeesParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching employees.
	Query *string `json:"query,omitempty"`

	// Search for employees with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// GetExpensesParams defines parameters for GetExpenses.
type GetExpensesParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching customers.
	Query *string `json:"query,omitempty"`

	// Search for customers with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// PostExpensesIdJSONBody defines parameters for PostExpensesId.
type PostExpensesIdJSONBody struct {

	// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
	AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

	// Refers to the third party which advanced the payment
	AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

	// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
	Amount *string `json:"amount,omitempty"`

	// States whether the costs for the Expense will be forwarded to the customer
	Billable *bool `json:"billable,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

	// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
	ExpenseCategory *string `json:"expenseCategory,omitempty"`

	// Unique user-chosen identifier for a Expense, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// States whether this Expense is for an internal purpose or not.
	Internal *bool `json:"internal,omitempty"`

	// Describes meaningful manner the Expense
	Name *string `json:"name,omitempty"`

	// Refers to the customer which have to pay the Expense
	ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

	// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
	PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

	// The full path to the business record document (PDF or PNG)
	Path *string `json:"path,omitempty"`

	// Refers to the associated project.
	ProjectId *string `json:"projectId,omitempty"`

	// Refers to a possible bank transaction which settled the Expense for the company
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// PutExpensesIdJSONBody defines parameters for PutExpensesId.
type PutExpensesIdJSONBody struct {

	// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
	AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

	// Refers to the third party which advanced the payment
	AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

	// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
	Amount *string `json:"amount,omitempty"`

	// States whether the costs for the Expense will be forwarded to the customer
	Billable *bool `json:"billable,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

	// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
	ExpenseCategory *string `json:"expenseCategory,omitempty"`

	// Unique user-chosen identifier for a Expense, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// States whether this Expense is for an internal purpose or not.
	Internal *bool `json:"internal,omitempty"`

	// Describes meaningful manner the Expense
	Name *string `json:"name,omitempty"`

	// Refers to the customer which have to pay the Expense
	ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

	// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
	PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

	// The full path to the business record document (PDF or PNG)
	Path *string `json:"path,omitempty"`

	// Refers to the associated project.
	ProjectId *string `json:"projectId,omitempty"`

	// Refers to a possible bank transaction which settled the Expense for the company
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// GetInvoicesParams defines parameters for GetInvoices.
type GetInvoicesParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching customers.
	Query *string `json:"query,omitempty"`

	// Search for customers with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// PostInvoicesIdJSONBody defines parameters for PostInvoicesId.
type PostInvoicesIdJSONBody struct {

	// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
	Amount *string `json:"amount,omitempty"`

	// Refers to the customer the Invoice was sent to.
	CustomerId *string `json:"customerId,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

	// Unique user-chosen identifier for a Invoice, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Describes the Invoice.
	Name *string `json:"name,omitempty"`

	// The full path to the business record document (PDF or PNG).
	Path *string `json:"path,omitempty"`

	// Refers to the associated project.
	ProjectId *string `json:"projectId,omitempty"`

	// Revoked Invoices are disabled an no longer taken into account.
	Revoked *bool `json:"revoked,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	SendDate *string `json:"sendDate,omitempty"`

	// Refers to a possible bank transaction which settled the Invoice for the company.
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// PutInvoicesIdJSONBody defines parameters for PutInvoicesId.
type PutInvoicesIdJSONBody struct {

	// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
	Amount *string `json:"amount,omitempty"`

	// Refers to the customer the Invoice was sent to.
	CustomerId *string `json:"customerId,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

	// Unique user-chosen identifier for a Invoice, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Describes the Invoice.
	Name *string `json:"name,omitempty"`

	// The full path to the business record document (PDF or PNG).
	Path *string `json:"path,omitempty"`

	// Refers to the associated project.
	ProjectId *string `json:"projectId,omitempty"`

	// Revoked Invoices are disabled an no longer taken into account.
	Revoked *bool `json:"revoked,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	SendDate *string `json:"sendDate,omitempty"`

	// Refers to a possible bank transaction which settled the Invoice for the company.
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// GetMiscRecordsParams defines parameters for GetMiscRecords.
type GetMiscRecordsParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching customers.
	Query *string `json:"query,omitempty"`

	// Search for customers with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// PostMiscRecordsIdJSONBody defines parameters for PostMiscRecordsId.
type PostMiscRecordsIdJSONBody struct {

	// A date in the calender in the format YYYY-MM-DD
	Date *string `json:"date,omitempty"`

	// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the Miscellaneous Record.
	Name *string `json:"name,omitempty"`

	// The full path to the business record document (PDF or PNG)
	Path *string `json:"path,omitempty"`

	// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// PutMiscRecordsIdJSONBody defines parameters for PutMiscRecordsId.
type PutMiscRecordsIdJSONBody struct {

	// A date in the calender in the format YYYY-MM-DD
	Date *string `json:"date,omitempty"`

	// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the Miscellaneous Record.
	Name *string `json:"name,omitempty"`

	// The full path to the business record document (PDF or PNG)
	Path *string `json:"path,omitempty"`

	// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// GetProjectsParams defines parameters for GetProjects.
type GetProjectsParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching customers.
	Query *string `json:"query,omitempty"`

	// Search for customers with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// PostProjectsIdJSONBody defines parameters for PostProjectsId.
type PostProjectsIdJSONBody struct {

	// Refers to the customer the project is associated to.
	CustomerId *string `json:"customerId,omitempty"`

	// Unique user-chosen identifier for a Project, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the Project.
	Name *string `json:"name,omitempty"`
}

// PutProjectsIdJSONBody defines parameters for PutProjectsId.
type PutProjectsIdJSONBody struct {

	// Refers to the customer the project is associated to.
	CustomerId *string `json:"customerId,omitempty"`

	// Unique user-chosen identifier for a Project, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the Project.
	Name *string `json:"name,omitempty"`
}

// PostCustomersIdRequestBody defines body for PostCustomersId for application/json ContentType.
type PostCustomersIdJSONRequestBody PostCustomersIdJSONBody

// PutCustomersIdRequestBody defines body for PutCustomersId for application/json ContentType.
type PutCustomersIdJSONRequestBody PutCustomersIdJSONBody

// PostExpensesIdRequestBody defines body for PostExpensesId for application/json ContentType.
type PostExpensesIdJSONRequestBody PostExpensesIdJSONBody

// PutExpensesIdRequestBody defines body for PutExpensesId for application/json ContentType.
type PutExpensesIdJSONRequestBody PutExpensesIdJSONBody

// PostInvoicesIdRequestBody defines body for PostInvoicesId for application/json ContentType.
type PostInvoicesIdJSONRequestBody PostInvoicesIdJSONBody

// PutInvoicesIdRequestBody defines body for PutInvoicesId for application/json ContentType.
type PutInvoicesIdJSONRequestBody PutInvoicesIdJSONBody

// PostMiscRecordsIdRequestBody defines body for PostMiscRecordsId for application/json ContentType.
type PostMiscRecordsIdJSONRequestBody PostMiscRecordsIdJSONBody

// PutMiscRecordsIdRequestBody defines body for PutMiscRecordsId for application/json ContentType.
type PutMiscRecordsIdJSONRequestBody PutMiscRecordsIdJSONBody

// PostProjectsIdRequestBody defines body for PostProjectsId for application/json ContentType.
type PostProjectsIdJSONRequestBody PostProjectsIdJSONBody

// PutProjectsIdRequestBody defines body for PutProjectsId for application/json ContentType.
type PutProjectsIdJSONRequestBody PutProjectsIdJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCustomers request
	GetCustomers(ctx context.Context, params *GetCustomersParams) (*http.Response, error)

	// DeleteCustomersId request
	DeleteCustomersId(ctx context.Context, id string) (*http.Response, error)

	// GetCustomersId request
	GetCustomersId(ctx context.Context, id string) (*http.Response, error)

	// PostCustomersId request  with any body
	PostCustomersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PostCustomersId(ctx context.Context, id string, body PostCustomersIdJSONRequestBody) (*http.Response, error)

	// PutCustomersId request  with any body
	PutCustomersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PutCustomersId(ctx context.Context, id string, body PutCustomersIdJSONRequestBody) (*http.Response, error)

	// GetEmployees request
	GetEmployees(ctx context.Context, params *GetEmployeesParams) (*http.Response, error)

	// GetExpenses request
	GetExpenses(ctx context.Context, params *GetExpensesParams) (*http.Response, error)

	// DeleteExpensesId request
	DeleteExpensesId(ctx context.Context, id string) (*http.Response, error)

	// GetExpensesId request
	GetExpensesId(ctx context.Context, id string) (*http.Response, error)

	// PostExpensesId request  with any body
	PostExpensesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PostExpensesId(ctx context.Context, id string, body PostExpensesIdJSONRequestBody) (*http.Response, error)

	// PutExpensesId request  with any body
	PutExpensesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PutExpensesId(ctx context.Context, id string, body PutExpensesIdJSONRequestBody) (*http.Response, error)

	// GetInvoices request
	GetInvoices(ctx context.Context, params *GetInvoicesParams) (*http.Response, error)

	// DeleteInvoicesId request
	DeleteInvoicesId(ctx context.Context, id string) (*http.Response, error)

	// GetInvoicesId request
	GetInvoicesId(ctx context.Context, id string) (*http.Response, error)

	// PostInvoicesId request  with any body
	PostInvoicesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PostInvoicesId(ctx context.Context, id string, body PostInvoicesIdJSONRequestBody) (*http.Response, error)

	// PutInvoicesId request  with any body
	PutInvoicesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PutInvoicesId(ctx context.Context, id string, body PutInvoicesIdJSONRequestBody) (*http.Response, error)

	// GetMiscRecords request
	GetMiscRecords(ctx context.Context, params *GetMiscRecordsParams) (*http.Response, error)

	// DeleteMiscRecordsId request
	DeleteMiscRecordsId(ctx context.Context, id string) (*http.Response, error)

	// GetMiscRecordsId request
	GetMiscRecordsId(ctx context.Context, id string) (*http.Response, error)

	// PostMiscRecordsId request  with any body
	PostMiscRecordsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PostMiscRecordsId(ctx context.Context, id string, body PostMiscRecordsIdJSONRequestBody) (*http.Response, error)

	// PutMiscRecordsId request  with any body
	PutMiscRecordsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PutMiscRecordsId(ctx context.Context, id string, body PutMiscRecordsIdJSONRequestBody) (*http.Response, error)

	// GetProjects request
	GetProjects(ctx context.Context, params *GetProjectsParams) (*http.Response, error)

	// DeleteProjectsId request
	DeleteProjectsId(ctx context.Context, id string) (*http.Response, error)

	// GetProjectsId request
	GetProjectsId(ctx context.Context, id string) (*http.Response, error)

	// PostProjectsId request  with any body
	PostProjectsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PostProjectsId(ctx context.Context, id string, body PostProjectsIdJSONRequestBody) (*http.Response, error)

	// PutProjectsId request  with any body
	PutProjectsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PutProjectsId(ctx context.Context, id string, body PutProjectsIdJSONRequestBody) (*http.Response, error)
}

func (c *Client) GetCustomers(ctx context.Context, params *GetCustomersParams) (*http.Response, error) {
	req, err := NewGetCustomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomersId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeleteCustomersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomersId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetCustomersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostCustomersIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersId(ctx context.Context, id string, body PostCustomersIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPostCustomersIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutCustomersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutCustomersIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutCustomersId(ctx context.Context, id string, body PutCustomersIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPutCustomersIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmployees(ctx context.Context, params *GetEmployeesParams) (*http.Response, error) {
	req, err := NewGetEmployeesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetExpenses(ctx context.Context, params *GetExpensesParams) (*http.Response, error) {
	req, err := NewGetExpensesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExpensesId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeleteExpensesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetExpensesId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetExpensesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostExpensesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostExpensesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostExpensesId(ctx context.Context, id string, body PostExpensesIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPostExpensesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutExpensesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutExpensesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutExpensesId(ctx context.Context, id string, body PutExpensesIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPutExpensesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoices(ctx context.Context, params *GetInvoicesParams) (*http.Response, error) {
	req, err := NewGetInvoicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvoicesId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeleteInvoicesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoicesId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetInvoicesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvoicesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostInvoicesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvoicesId(ctx context.Context, id string, body PostInvoicesIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPostInvoicesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutInvoicesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutInvoicesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutInvoicesId(ctx context.Context, id string, body PutInvoicesIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPutInvoicesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMiscRecords(ctx context.Context, params *GetMiscRecordsParams) (*http.Response, error) {
	req, err := NewGetMiscRecordsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMiscRecordsId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeleteMiscRecordsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMiscRecordsId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetMiscRecordsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostMiscRecordsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostMiscRecordsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostMiscRecordsId(ctx context.Context, id string, body PostMiscRecordsIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPostMiscRecordsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutMiscRecordsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutMiscRecordsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutMiscRecordsId(ctx context.Context, id string, body PutMiscRecordsIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPutMiscRecordsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjects(ctx context.Context, params *GetProjectsParams) (*http.Response, error) {
	req, err := NewGetProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectsId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeleteProjectsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectsId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetProjectsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostProjectsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostProjectsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostProjectsId(ctx context.Context, id string, body PostProjectsIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPostProjectsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutProjectsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutProjectsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutProjectsId(ctx context.Context, id string, body PutProjectsIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPutProjectsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewGetCustomersRequest generates requests for GetCustomers
func NewGetCustomersRequest(server string, params *GetCustomersParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/customers")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCustomersIdRequest generates requests for DeleteCustomersId
func NewDeleteCustomersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/customers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomersIdRequest generates requests for GetCustomersId
func NewGetCustomersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/customers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomersIdRequest calls the generic PostCustomersId builder with application/json body
func NewPostCustomersIdRequest(server string, id string, body PostCustomersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomersIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostCustomersIdRequestWithBody generates requests for PostCustomersId with any type of body
func NewPostCustomersIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/customers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPutCustomersIdRequest calls the generic PutCustomersId builder with application/json body
func NewPutCustomersIdRequest(server string, id string, body PutCustomersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutCustomersIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutCustomersIdRequestWithBody generates requests for PutCustomersId with any type of body
func NewPutCustomersIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/customers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetEmployeesRequest generates requests for GetEmployees
func NewGetEmployeesRequest(server string, params *GetEmployeesParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/employees")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExpensesRequest generates requests for GetExpenses
func NewGetExpensesRequest(server string, params *GetExpensesParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/expenses")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteExpensesIdRequest generates requests for DeleteExpensesId
func NewDeleteExpensesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/expenses/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExpensesIdRequest generates requests for GetExpensesId
func NewGetExpensesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/expenses/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExpensesIdRequest calls the generic PostExpensesId builder with application/json body
func NewPostExpensesIdRequest(server string, id string, body PostExpensesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExpensesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostExpensesIdRequestWithBody generates requests for PostExpensesId with any type of body
func NewPostExpensesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/expenses/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPutExpensesIdRequest calls the generic PutExpensesId builder with application/json body
func NewPutExpensesIdRequest(server string, id string, body PutExpensesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutExpensesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutExpensesIdRequestWithBody generates requests for PutExpensesId with any type of body
func NewPutExpensesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/expenses/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetInvoicesRequest generates requests for GetInvoices
func NewGetInvoicesRequest(server string, params *GetInvoicesParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/invoices")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInvoicesIdRequest generates requests for DeleteInvoicesId
func NewDeleteInvoicesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/invoices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoicesIdRequest generates requests for GetInvoicesId
func NewGetInvoicesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/invoices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInvoicesIdRequest calls the generic PostInvoicesId builder with application/json body
func NewPostInvoicesIdRequest(server string, id string, body PostInvoicesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInvoicesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostInvoicesIdRequestWithBody generates requests for PostInvoicesId with any type of body
func NewPostInvoicesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/invoices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPutInvoicesIdRequest calls the generic PutInvoicesId builder with application/json body
func NewPutInvoicesIdRequest(server string, id string, body PutInvoicesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutInvoicesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutInvoicesIdRequestWithBody generates requests for PutInvoicesId with any type of body
func NewPutInvoicesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/invoices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetMiscRecordsRequest generates requests for GetMiscRecords
func NewGetMiscRecordsRequest(server string, params *GetMiscRecordsParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/misc_records")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMiscRecordsIdRequest generates requests for DeleteMiscRecordsId
func NewDeleteMiscRecordsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/misc_records/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMiscRecordsIdRequest generates requests for GetMiscRecordsId
func NewGetMiscRecordsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/misc_records/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMiscRecordsIdRequest calls the generic PostMiscRecordsId builder with application/json body
func NewPostMiscRecordsIdRequest(server string, id string, body PostMiscRecordsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMiscRecordsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostMiscRecordsIdRequestWithBody generates requests for PostMiscRecordsId with any type of body
func NewPostMiscRecordsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/misc_records/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPutMiscRecordsIdRequest calls the generic PutMiscRecordsId builder with application/json body
func NewPutMiscRecordsIdRequest(server string, id string, body PutMiscRecordsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutMiscRecordsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutMiscRecordsIdRequestWithBody generates requests for PutMiscRecordsId with any type of body
func NewPutMiscRecordsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/misc_records/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetProjectsRequest generates requests for GetProjects
func NewGetProjectsRequest(server string, params *GetProjectsParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProjectsIdRequest generates requests for DeleteProjectsId
func NewDeleteProjectsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectsIdRequest generates requests for GetProjectsId
func NewGetProjectsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProjectsIdRequest calls the generic PostProjectsId builder with application/json body
func NewPostProjectsIdRequest(server string, id string, body PostProjectsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProjectsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostProjectsIdRequestWithBody generates requests for PostProjectsId with any type of body
func NewPostProjectsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPutProjectsIdRequest calls the generic PutProjectsId builder with application/json body
func NewPutProjectsIdRequest(server string, id string, body PutProjectsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutProjectsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutProjectsIdRequestWithBody generates requests for PutProjectsId with any type of body
func NewPutProjectsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCustomers request
	GetCustomersWithResponse(ctx context.Context, params *GetCustomersParams) (*GetCustomersResponse, error)

	// DeleteCustomersId request
	DeleteCustomersIdWithResponse(ctx context.Context, id string) (*DeleteCustomersIdResponse, error)

	// GetCustomersId request
	GetCustomersIdWithResponse(ctx context.Context, id string) (*GetCustomersIdResponse, error)

	// PostCustomersId request  with any body
	PostCustomersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostCustomersIdResponse, error)

	PostCustomersIdWithResponse(ctx context.Context, id string, body PostCustomersIdJSONRequestBody) (*PostCustomersIdResponse, error)

	// PutCustomersId request  with any body
	PutCustomersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutCustomersIdResponse, error)

	PutCustomersIdWithResponse(ctx context.Context, id string, body PutCustomersIdJSONRequestBody) (*PutCustomersIdResponse, error)

	// GetEmployees request
	GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams) (*GetEmployeesResponse, error)

	// GetExpenses request
	GetExpensesWithResponse(ctx context.Context, params *GetExpensesParams) (*GetExpensesResponse, error)

	// DeleteExpensesId request
	DeleteExpensesIdWithResponse(ctx context.Context, id string) (*DeleteExpensesIdResponse, error)

	// GetExpensesId request
	GetExpensesIdWithResponse(ctx context.Context, id string) (*GetExpensesIdResponse, error)

	// PostExpensesId request  with any body
	PostExpensesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostExpensesIdResponse, error)

	PostExpensesIdWithResponse(ctx context.Context, id string, body PostExpensesIdJSONRequestBody) (*PostExpensesIdResponse, error)

	// PutExpensesId request  with any body
	PutExpensesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutExpensesIdResponse, error)

	PutExpensesIdWithResponse(ctx context.Context, id string, body PutExpensesIdJSONRequestBody) (*PutExpensesIdResponse, error)

	// GetInvoices request
	GetInvoicesWithResponse(ctx context.Context, params *GetInvoicesParams) (*GetInvoicesResponse, error)

	// DeleteInvoicesId request
	DeleteInvoicesIdWithResponse(ctx context.Context, id string) (*DeleteInvoicesIdResponse, error)

	// GetInvoicesId request
	GetInvoicesIdWithResponse(ctx context.Context, id string) (*GetInvoicesIdResponse, error)

	// PostInvoicesId request  with any body
	PostInvoicesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostInvoicesIdResponse, error)

	PostInvoicesIdWithResponse(ctx context.Context, id string, body PostInvoicesIdJSONRequestBody) (*PostInvoicesIdResponse, error)

	// PutInvoicesId request  with any body
	PutInvoicesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutInvoicesIdResponse, error)

	PutInvoicesIdWithResponse(ctx context.Context, id string, body PutInvoicesIdJSONRequestBody) (*PutInvoicesIdResponse, error)

	// GetMiscRecords request
	GetMiscRecordsWithResponse(ctx context.Context, params *GetMiscRecordsParams) (*GetMiscRecordsResponse, error)

	// DeleteMiscRecordsId request
	DeleteMiscRecordsIdWithResponse(ctx context.Context, id string) (*DeleteMiscRecordsIdResponse, error)

	// GetMiscRecordsId request
	GetMiscRecordsIdWithResponse(ctx context.Context, id string) (*GetMiscRecordsIdResponse, error)

	// PostMiscRecordsId request  with any body
	PostMiscRecordsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostMiscRecordsIdResponse, error)

	PostMiscRecordsIdWithResponse(ctx context.Context, id string, body PostMiscRecordsIdJSONRequestBody) (*PostMiscRecordsIdResponse, error)

	// PutMiscRecordsId request  with any body
	PutMiscRecordsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutMiscRecordsIdResponse, error)

	PutMiscRecordsIdWithResponse(ctx context.Context, id string, body PutMiscRecordsIdJSONRequestBody) (*PutMiscRecordsIdResponse, error)

	// GetProjects request
	GetProjectsWithResponse(ctx context.Context, params *GetProjectsParams) (*GetProjectsResponse, error)

	// DeleteProjectsId request
	DeleteProjectsIdWithResponse(ctx context.Context, id string) (*DeleteProjectsIdResponse, error)

	// GetProjectsId request
	GetProjectsIdWithResponse(ctx context.Context, id string) (*GetProjectsIdResponse, error)

	// PostProjectsId request  with any body
	PostProjectsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostProjectsIdResponse, error)

	PostProjectsIdWithResponse(ctx context.Context, id string, body PostProjectsIdJSONRequestBody) (*PostProjectsIdResponse, error)

	// PutProjectsId request  with any body
	PutProjectsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutProjectsIdResponse, error)

	PutProjectsIdWithResponse(ctx context.Context, id string, body PutProjectsIdJSONRequestBody) (*PutProjectsIdResponse, error)
}

type GetCustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`

		// Unique user-chosen identifier for a Party, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the person/company
		Name *string `json:"name,omitempty"`

		// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
		PartyType *int `json:"partyType,omitempty"`

		// Name of the place
		Place *string `json:"place,omitempty"`

		// ZIP/Postal-Code of the address
		PostalCode *int `json:"postalCode,omitempty"`

		// Name of the street the party residence in
		Street *string `json:"street,omitempty"`

		// Street number of party's address
		StreetNr *int `json:"streetNr,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`

		// Unique user-chosen identifier for a Party, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the person/company
		Name *string `json:"name,omitempty"`

		// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
		PartyType *int `json:"partyType,omitempty"`

		// Name of the place
		Place *string `json:"place,omitempty"`

		// ZIP/Postal-Code of the address
		PostalCode *int `json:"postalCode,omitempty"`

		// Name of the street the party residence in
		Street *string `json:"street,omitempty"`

		// Street number of party's address
		StreetNr *int `json:"streetNr,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`

		// Unique user-chosen identifier for a Party, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the person/company
		Name *string `json:"name,omitempty"`

		// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
		PartyType *int `json:"partyType,omitempty"`

		// Name of the place
		Place *string `json:"place,omitempty"`

		// ZIP/Postal-Code of the address
		PostalCode *int `json:"postalCode,omitempty"`

		// Name of the street the party residence in
		Street *string `json:"street,omitempty"`

		// Street number of party's address
		StreetNr *int `json:"streetNr,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEmployeesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExpensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
		AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

		// Refers to the third party which advanced the payment
		AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

		// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
		Amount *string `json:"amount,omitempty"`

		// States whether the costs for the Expense will be forwarded to the customer
		Billable *bool `json:"billable,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

		// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
		ExpenseCategory *string `json:"expenseCategory,omitempty"`

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`

		// Unique user-chosen identifier for a Expense, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// States whether this Expense is for an internal purpose or not.
		Internal *bool `json:"internal,omitempty"`

		// Describes meaningful manner the Expense
		Name *string `json:"name,omitempty"`

		// Refers to the customer which have to pay the Expense
		ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

		// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
		PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

		// The full path to the business record document (PDF or PNG)
		Path *string `json:"path,omitempty"`

		// Refers to the associated project.
		ProjectId *string `json:"projectId,omitempty"`

		// Refers to a possible bank transaction which settled the Expense for the company
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetExpensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExpensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExpensesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteExpensesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExpensesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExpensesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
		AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

		// Refers to the third party which advanced the payment
		AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

		// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
		Amount *string `json:"amount,omitempty"`

		// States whether the costs for the Expense will be forwarded to the customer
		Billable *bool `json:"billable,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

		// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
		ExpenseCategory *string `json:"expenseCategory,omitempty"`

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`

		// Unique user-chosen identifier for a Expense, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// States whether this Expense is for an internal purpose or not.
		Internal *bool `json:"internal,omitempty"`

		// Describes meaningful manner the Expense
		Name *string `json:"name,omitempty"`

		// Refers to the customer which have to pay the Expense
		ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

		// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
		PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

		// The full path to the business record document (PDF or PNG)
		Path *string `json:"path,omitempty"`

		// Refers to the associated project.
		ProjectId *string `json:"projectId,omitempty"`

		// Refers to a possible bank transaction which settled the Expense for the company
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetExpensesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExpensesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExpensesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostExpensesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExpensesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutExpensesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutExpensesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutExpensesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
		Amount *string `json:"amount,omitempty"`

		// Refers to the customer the Invoice was sent to.
		CustomerId *string `json:"customerId,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`

		// Unique user-chosen identifier for a Invoice, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Describes the Invoice.
		Name *string `json:"name,omitempty"`

		// The full path to the business record document (PDF or PNG).
		Path *string `json:"path,omitempty"`

		// Refers to the associated project.
		ProjectId *string `json:"projectId,omitempty"`

		// Revoked Invoices are disabled an no longer taken into account.
		Revoked *bool `json:"revoked,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		SendDate *string `json:"sendDate,omitempty"`

		// Refers to a possible bank transaction which settled the Invoice for the company.
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInvoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInvoicesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInvoicesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInvoicesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
		Amount *string `json:"amount,omitempty"`

		// Refers to the customer the Invoice was sent to.
		CustomerId *string `json:"customerId,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`

		// Unique user-chosen identifier for a Invoice, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Describes the Invoice.
		Name *string `json:"name,omitempty"`

		// The full path to the business record document (PDF or PNG).
		Path *string `json:"path,omitempty"`

		// Refers to the associated project.
		ProjectId *string `json:"projectId,omitempty"`

		// Revoked Invoices are disabled an no longer taken into account.
		Revoked *bool `json:"revoked,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		SendDate *string `json:"sendDate,omitempty"`

		// Refers to a possible bank transaction which settled the Invoice for the company.
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInvoicesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInvoicesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostInvoicesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvoicesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutInvoicesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutInvoicesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutInvoicesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMiscRecordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// A date in the calender in the format YYYY-MM-DD
		Date *string `json:"date,omitempty"`

		// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the Miscellaneous Record.
		Name *string `json:"name,omitempty"`

		// The full path to the business record document (PDF or PNG)
		Path *string `json:"path,omitempty"`

		// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMiscRecordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMiscRecordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMiscRecordsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMiscRecordsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMiscRecordsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMiscRecordsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// A date in the calender in the format YYYY-MM-DD
		Date *string `json:"date,omitempty"`

		// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the Miscellaneous Record.
		Name *string `json:"name,omitempty"`

		// The full path to the business record document (PDF or PNG)
		Path *string `json:"path,omitempty"`

		// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMiscRecordsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMiscRecordsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMiscRecordsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostMiscRecordsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMiscRecordsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutMiscRecordsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutMiscRecordsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutMiscRecordsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {

		// Refers to the customer the project is associated to.
		CustomerId *string `json:"customerId,omitempty"`

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`

		// Unique user-chosen identifier for a Project, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the Project.
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {

		// Refers to the customer the project is associated to.
		CustomerId *string `json:"customerId,omitempty"`

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`

		// Unique user-chosen identifier for a Project, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the Project.
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCustomersWithResponse request returning *GetCustomersResponse
func (c *ClientWithResponses) GetCustomersWithResponse(ctx context.Context, params *GetCustomersParams) (*GetCustomersResponse, error) {
	rsp, err := c.GetCustomers(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomersResponse(rsp)
}

// DeleteCustomersIdWithResponse request returning *DeleteCustomersIdResponse
func (c *ClientWithResponses) DeleteCustomersIdWithResponse(ctx context.Context, id string) (*DeleteCustomersIdResponse, error) {
	rsp, err := c.DeleteCustomersId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomersIdResponse(rsp)
}

// GetCustomersIdWithResponse request returning *GetCustomersIdResponse
func (c *ClientWithResponses) GetCustomersIdWithResponse(ctx context.Context, id string) (*GetCustomersIdResponse, error) {
	rsp, err := c.GetCustomersId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomersIdResponse(rsp)
}

// PostCustomersIdWithBodyWithResponse request with arbitrary body returning *PostCustomersIdResponse
func (c *ClientWithResponses) PostCustomersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostCustomersIdResponse, error) {
	rsp, err := c.PostCustomersIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersIdResponse(rsp)
}

func (c *ClientWithResponses) PostCustomersIdWithResponse(ctx context.Context, id string, body PostCustomersIdJSONRequestBody) (*PostCustomersIdResponse, error) {
	rsp, err := c.PostCustomersId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersIdResponse(rsp)
}

// PutCustomersIdWithBodyWithResponse request with arbitrary body returning *PutCustomersIdResponse
func (c *ClientWithResponses) PutCustomersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutCustomersIdResponse, error) {
	rsp, err := c.PutCustomersIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutCustomersIdResponse(rsp)
}

func (c *ClientWithResponses) PutCustomersIdWithResponse(ctx context.Context, id string, body PutCustomersIdJSONRequestBody) (*PutCustomersIdResponse, error) {
	rsp, err := c.PutCustomersId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePutCustomersIdResponse(rsp)
}

// GetEmployeesWithResponse request returning *GetEmployeesResponse
func (c *ClientWithResponses) GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams) (*GetEmployeesResponse, error) {
	rsp, err := c.GetEmployees(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeesResponse(rsp)
}

// GetExpensesWithResponse request returning *GetExpensesResponse
func (c *ClientWithResponses) GetExpensesWithResponse(ctx context.Context, params *GetExpensesParams) (*GetExpensesResponse, error) {
	rsp, err := c.GetExpenses(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetExpensesResponse(rsp)
}

// DeleteExpensesIdWithResponse request returning *DeleteExpensesIdResponse
func (c *ClientWithResponses) DeleteExpensesIdWithResponse(ctx context.Context, id string) (*DeleteExpensesIdResponse, error) {
	rsp, err := c.DeleteExpensesId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExpensesIdResponse(rsp)
}

// GetExpensesIdWithResponse request returning *GetExpensesIdResponse
func (c *ClientWithResponses) GetExpensesIdWithResponse(ctx context.Context, id string) (*GetExpensesIdResponse, error) {
	rsp, err := c.GetExpensesId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetExpensesIdResponse(rsp)
}

// PostExpensesIdWithBodyWithResponse request with arbitrary body returning *PostExpensesIdResponse
func (c *ClientWithResponses) PostExpensesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostExpensesIdResponse, error) {
	rsp, err := c.PostExpensesIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostExpensesIdResponse(rsp)
}

func (c *ClientWithResponses) PostExpensesIdWithResponse(ctx context.Context, id string, body PostExpensesIdJSONRequestBody) (*PostExpensesIdResponse, error) {
	rsp, err := c.PostExpensesId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostExpensesIdResponse(rsp)
}

// PutExpensesIdWithBodyWithResponse request with arbitrary body returning *PutExpensesIdResponse
func (c *ClientWithResponses) PutExpensesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutExpensesIdResponse, error) {
	rsp, err := c.PutExpensesIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutExpensesIdResponse(rsp)
}

func (c *ClientWithResponses) PutExpensesIdWithResponse(ctx context.Context, id string, body PutExpensesIdJSONRequestBody) (*PutExpensesIdResponse, error) {
	rsp, err := c.PutExpensesId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePutExpensesIdResponse(rsp)
}

// GetInvoicesWithResponse request returning *GetInvoicesResponse
func (c *ClientWithResponses) GetInvoicesWithResponse(ctx context.Context, params *GetInvoicesParams) (*GetInvoicesResponse, error) {
	rsp, err := c.GetInvoices(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesResponse(rsp)
}

// DeleteInvoicesIdWithResponse request returning *DeleteInvoicesIdResponse
func (c *ClientWithResponses) DeleteInvoicesIdWithResponse(ctx context.Context, id string) (*DeleteInvoicesIdResponse, error) {
	rsp, err := c.DeleteInvoicesId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInvoicesIdResponse(rsp)
}

// GetInvoicesIdWithResponse request returning *GetInvoicesIdResponse
func (c *ClientWithResponses) GetInvoicesIdWithResponse(ctx context.Context, id string) (*GetInvoicesIdResponse, error) {
	rsp, err := c.GetInvoicesId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesIdResponse(rsp)
}

// PostInvoicesIdWithBodyWithResponse request with arbitrary body returning *PostInvoicesIdResponse
func (c *ClientWithResponses) PostInvoicesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostInvoicesIdResponse, error) {
	rsp, err := c.PostInvoicesIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostInvoicesIdResponse(rsp)
}

func (c *ClientWithResponses) PostInvoicesIdWithResponse(ctx context.Context, id string, body PostInvoicesIdJSONRequestBody) (*PostInvoicesIdResponse, error) {
	rsp, err := c.PostInvoicesId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostInvoicesIdResponse(rsp)
}

// PutInvoicesIdWithBodyWithResponse request with arbitrary body returning *PutInvoicesIdResponse
func (c *ClientWithResponses) PutInvoicesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutInvoicesIdResponse, error) {
	rsp, err := c.PutInvoicesIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutInvoicesIdResponse(rsp)
}

func (c *ClientWithResponses) PutInvoicesIdWithResponse(ctx context.Context, id string, body PutInvoicesIdJSONRequestBody) (*PutInvoicesIdResponse, error) {
	rsp, err := c.PutInvoicesId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePutInvoicesIdResponse(rsp)
}

// GetMiscRecordsWithResponse request returning *GetMiscRecordsResponse
func (c *ClientWithResponses) GetMiscRecordsWithResponse(ctx context.Context, params *GetMiscRecordsParams) (*GetMiscRecordsResponse, error) {
	rsp, err := c.GetMiscRecords(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetMiscRecordsResponse(rsp)
}

// DeleteMiscRecordsIdWithResponse request returning *DeleteMiscRecordsIdResponse
func (c *ClientWithResponses) DeleteMiscRecordsIdWithResponse(ctx context.Context, id string) (*DeleteMiscRecordsIdResponse, error) {
	rsp, err := c.DeleteMiscRecordsId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMiscRecordsIdResponse(rsp)
}

// GetMiscRecordsIdWithResponse request returning *GetMiscRecordsIdResponse
func (c *ClientWithResponses) GetMiscRecordsIdWithResponse(ctx context.Context, id string) (*GetMiscRecordsIdResponse, error) {
	rsp, err := c.GetMiscRecordsId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetMiscRecordsIdResponse(rsp)
}

// PostMiscRecordsIdWithBodyWithResponse request with arbitrary body returning *PostMiscRecordsIdResponse
func (c *ClientWithResponses) PostMiscRecordsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostMiscRecordsIdResponse, error) {
	rsp, err := c.PostMiscRecordsIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostMiscRecordsIdResponse(rsp)
}

func (c *ClientWithResponses) PostMiscRecordsIdWithResponse(ctx context.Context, id string, body PostMiscRecordsIdJSONRequestBody) (*PostMiscRecordsIdResponse, error) {
	rsp, err := c.PostMiscRecordsId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostMiscRecordsIdResponse(rsp)
}

// PutMiscRecordsIdWithBodyWithResponse request with arbitrary body returning *PutMiscRecordsIdResponse
func (c *ClientWithResponses) PutMiscRecordsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutMiscRecordsIdResponse, error) {
	rsp, err := c.PutMiscRecordsIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutMiscRecordsIdResponse(rsp)
}

func (c *ClientWithResponses) PutMiscRecordsIdWithResponse(ctx context.Context, id string, body PutMiscRecordsIdJSONRequestBody) (*PutMiscRecordsIdResponse, error) {
	rsp, err := c.PutMiscRecordsId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePutMiscRecordsIdResponse(rsp)
}

// GetProjectsWithResponse request returning *GetProjectsResponse
func (c *ClientWithResponses) GetProjectsWithResponse(ctx context.Context, params *GetProjectsParams) (*GetProjectsResponse, error) {
	rsp, err := c.GetProjects(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsResponse(rsp)
}

// DeleteProjectsIdWithResponse request returning *DeleteProjectsIdResponse
func (c *ClientWithResponses) DeleteProjectsIdWithResponse(ctx context.Context, id string) (*DeleteProjectsIdResponse, error) {
	rsp, err := c.DeleteProjectsId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectsIdResponse(rsp)
}

// GetProjectsIdWithResponse request returning *GetProjectsIdResponse
func (c *ClientWithResponses) GetProjectsIdWithResponse(ctx context.Context, id string) (*GetProjectsIdResponse, error) {
	rsp, err := c.GetProjectsId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsIdResponse(rsp)
}

// PostProjectsIdWithBodyWithResponse request with arbitrary body returning *PostProjectsIdResponse
func (c *ClientWithResponses) PostProjectsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostProjectsIdResponse, error) {
	rsp, err := c.PostProjectsIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostProjectsIdResponse(rsp)
}

func (c *ClientWithResponses) PostProjectsIdWithResponse(ctx context.Context, id string, body PostProjectsIdJSONRequestBody) (*PostProjectsIdResponse, error) {
	rsp, err := c.PostProjectsId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostProjectsIdResponse(rsp)
}

// PutProjectsIdWithBodyWithResponse request with arbitrary body returning *PutProjectsIdResponse
func (c *ClientWithResponses) PutProjectsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutProjectsIdResponse, error) {
	rsp, err := c.PutProjectsIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutProjectsIdResponse(rsp)
}

func (c *ClientWithResponses) PutProjectsIdWithResponse(ctx context.Context, id string, body PutProjectsIdJSONRequestBody) (*PutProjectsIdResponse, error) {
	rsp, err := c.PutProjectsId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePutProjectsIdResponse(rsp)
}

// ParseGetCustomersResponse parses an HTTP response from a GetCustomersWithResponse call
func ParseGetCustomersResponse(rsp *http.Response) (*GetCustomersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`

			// Unique user-chosen identifier for a Party, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the person/company
			Name *string `json:"name,omitempty"`

			// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
			PartyType *int `json:"partyType,omitempty"`

			// Name of the place
			Place *string `json:"place,omitempty"`

			// ZIP/Postal-Code of the address
			PostalCode *int `json:"postalCode,omitempty"`

			// Name of the street the party residence in
			Street *string `json:"street,omitempty"`

			// Street number of party's address
			StreetNr *int `json:"streetNr,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomersIdResponse parses an HTTP response from a DeleteCustomersIdWithResponse call
func ParseDeleteCustomersIdResponse(rsp *http.Response) (*DeleteCustomersIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetCustomersIdResponse parses an HTTP response from a GetCustomersIdWithResponse call
func ParseGetCustomersIdResponse(rsp *http.Response) (*GetCustomersIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`

			// Unique user-chosen identifier for a Party, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the person/company
			Name *string `json:"name,omitempty"`

			// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
			PartyType *int `json:"partyType,omitempty"`

			// Name of the place
			Place *string `json:"place,omitempty"`

			// ZIP/Postal-Code of the address
			PostalCode *int `json:"postalCode,omitempty"`

			// Name of the street the party residence in
			Street *string `json:"street,omitempty"`

			// Street number of party's address
			StreetNr *int `json:"streetNr,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCustomersIdResponse parses an HTTP response from a PostCustomersIdWithResponse call
func ParsePostCustomersIdResponse(rsp *http.Response) (*PostCustomersIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePutCustomersIdResponse parses an HTTP response from a PutCustomersIdWithResponse call
func ParsePutCustomersIdResponse(rsp *http.Response) (*PutCustomersIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetEmployeesResponse parses an HTTP response from a GetEmployeesWithResponse call
func ParseGetEmployeesResponse(rsp *http.Response) (*GetEmployeesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`

			// Unique user-chosen identifier for a Party, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the person/company
			Name *string `json:"name,omitempty"`

			// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
			PartyType *int `json:"partyType,omitempty"`

			// Name of the place
			Place *string `json:"place,omitempty"`

			// ZIP/Postal-Code of the address
			PostalCode *int `json:"postalCode,omitempty"`

			// Name of the street the party residence in
			Street *string `json:"street,omitempty"`

			// Street number of party's address
			StreetNr *int `json:"streetNr,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExpensesResponse parses an HTTP response from a GetExpensesWithResponse call
func ParseGetExpensesResponse(rsp *http.Response) (*GetExpensesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetExpensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
			AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

			// Refers to the third party which advanced the payment
			AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

			// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
			Amount *string `json:"amount,omitempty"`

			// States whether the costs for the Expense will be forwarded to the customer
			Billable *bool `json:"billable,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

			// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
			ExpenseCategory *string `json:"expenseCategory,omitempty"`

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`

			// Unique user-chosen identifier for a Expense, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// States whether this Expense is for an internal purpose or not.
			Internal *bool `json:"internal,omitempty"`

			// Describes meaningful manner the Expense
			Name *string `json:"name,omitempty"`

			// Refers to the customer which have to pay the Expense
			ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

			// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
			PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

			// The full path to the business record document (PDF or PNG)
			Path *string `json:"path,omitempty"`

			// Refers to the associated project.
			ProjectId *string `json:"projectId,omitempty"`

			// Refers to a possible bank transaction which settled the Expense for the company
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteExpensesIdResponse parses an HTTP response from a DeleteExpensesIdWithResponse call
func ParseDeleteExpensesIdResponse(rsp *http.Response) (*DeleteExpensesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteExpensesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetExpensesIdResponse parses an HTTP response from a GetExpensesIdWithResponse call
func ParseGetExpensesIdResponse(rsp *http.Response) (*GetExpensesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetExpensesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
			AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

			// Refers to the third party which advanced the payment
			AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

			// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
			Amount *string `json:"amount,omitempty"`

			// States whether the costs for the Expense will be forwarded to the customer
			Billable *bool `json:"billable,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

			// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
			ExpenseCategory *string `json:"expenseCategory,omitempty"`

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`

			// Unique user-chosen identifier for a Expense, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// States whether this Expense is for an internal purpose or not.
			Internal *bool `json:"internal,omitempty"`

			// Describes meaningful manner the Expense
			Name *string `json:"name,omitempty"`

			// Refers to the customer which have to pay the Expense
			ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

			// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
			PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

			// The full path to the business record document (PDF or PNG)
			Path *string `json:"path,omitempty"`

			// Refers to the associated project.
			ProjectId *string `json:"projectId,omitempty"`

			// Refers to a possible bank transaction which settled the Expense for the company
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostExpensesIdResponse parses an HTTP response from a PostExpensesIdWithResponse call
func ParsePostExpensesIdResponse(rsp *http.Response) (*PostExpensesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostExpensesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePutExpensesIdResponse parses an HTTP response from a PutExpensesIdWithResponse call
func ParsePutExpensesIdResponse(rsp *http.Response) (*PutExpensesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutExpensesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetInvoicesResponse parses an HTTP response from a GetInvoicesWithResponse call
func ParseGetInvoicesResponse(rsp *http.Response) (*GetInvoicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
			Amount *string `json:"amount,omitempty"`

			// Refers to the customer the Invoice was sent to.
			CustomerId *string `json:"customerId,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`

			// Unique user-chosen identifier for a Invoice, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Describes the Invoice.
			Name *string `json:"name,omitempty"`

			// The full path to the business record document (PDF or PNG).
			Path *string `json:"path,omitempty"`

			// Refers to the associated project.
			ProjectId *string `json:"projectId,omitempty"`

			// Revoked Invoices are disabled an no longer taken into account.
			Revoked *bool `json:"revoked,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			SendDate *string `json:"sendDate,omitempty"`

			// Refers to a possible bank transaction which settled the Invoice for the company.
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteInvoicesIdResponse parses an HTTP response from a DeleteInvoicesIdWithResponse call
func ParseDeleteInvoicesIdResponse(rsp *http.Response) (*DeleteInvoicesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteInvoicesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetInvoicesIdResponse parses an HTTP response from a GetInvoicesIdWithResponse call
func ParseGetInvoicesIdResponse(rsp *http.Response) (*GetInvoicesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
			Amount *string `json:"amount,omitempty"`

			// Refers to the customer the Invoice was sent to.
			CustomerId *string `json:"customerId,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`

			// Unique user-chosen identifier for a Invoice, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Describes the Invoice.
			Name *string `json:"name,omitempty"`

			// The full path to the business record document (PDF or PNG).
			Path *string `json:"path,omitempty"`

			// Refers to the associated project.
			ProjectId *string `json:"projectId,omitempty"`

			// Revoked Invoices are disabled an no longer taken into account.
			Revoked *bool `json:"revoked,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			SendDate *string `json:"sendDate,omitempty"`

			// Refers to a possible bank transaction which settled the Invoice for the company.
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostInvoicesIdResponse parses an HTTP response from a PostInvoicesIdWithResponse call
func ParsePostInvoicesIdResponse(rsp *http.Response) (*PostInvoicesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostInvoicesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePutInvoicesIdResponse parses an HTTP response from a PutInvoicesIdWithResponse call
func ParsePutInvoicesIdResponse(rsp *http.Response) (*PutInvoicesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutInvoicesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetMiscRecordsResponse parses an HTTP response from a GetMiscRecordsWithResponse call
func ParseGetMiscRecordsResponse(rsp *http.Response) (*GetMiscRecordsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMiscRecordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// A date in the calender in the format YYYY-MM-DD
			Date *string `json:"date,omitempty"`

			// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the Miscellaneous Record.
			Name *string `json:"name,omitempty"`

			// The full path to the business record document (PDF or PNG)
			Path *string `json:"path,omitempty"`

			// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteMiscRecordsIdResponse parses an HTTP response from a DeleteMiscRecordsIdWithResponse call
func ParseDeleteMiscRecordsIdResponse(rsp *http.Response) (*DeleteMiscRecordsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteMiscRecordsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetMiscRecordsIdResponse parses an HTTP response from a GetMiscRecordsIdWithResponse call
func ParseGetMiscRecordsIdResponse(rsp *http.Response) (*GetMiscRecordsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMiscRecordsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// A date in the calender in the format YYYY-MM-DD
			Date *string `json:"date,omitempty"`

			// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the Miscellaneous Record.
			Name *string `json:"name,omitempty"`

			// The full path to the business record document (PDF or PNG)
			Path *string `json:"path,omitempty"`

			// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostMiscRecordsIdResponse parses an HTTP response from a PostMiscRecordsIdWithResponse call
func ParsePostMiscRecordsIdResponse(rsp *http.Response) (*PostMiscRecordsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostMiscRecordsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePutMiscRecordsIdResponse parses an HTTP response from a PutMiscRecordsIdWithResponse call
func ParsePutMiscRecordsIdResponse(rsp *http.Response) (*PutMiscRecordsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutMiscRecordsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetProjectsResponse parses an HTTP response from a GetProjectsWithResponse call
func ParseGetProjectsResponse(rsp *http.Response) (*GetProjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {

			// Refers to the customer the project is associated to.
			CustomerId *string `json:"customerId,omitempty"`

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`

			// Unique user-chosen identifier for a Project, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the Project.
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProjectsIdResponse parses an HTTP response from a DeleteProjectsIdWithResponse call
func ParseDeleteProjectsIdResponse(rsp *http.Response) (*DeleteProjectsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetProjectsIdResponse parses an HTTP response from a GetProjectsIdWithResponse call
func ParseGetProjectsIdResponse(rsp *http.Response) (*GetProjectsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {

			// Refers to the customer the project is associated to.
			CustomerId *string `json:"customerId,omitempty"`

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`

			// Unique user-chosen identifier for a Project, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the Project.
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostProjectsIdResponse parses an HTTP response from a PostProjectsIdWithResponse call
func ParsePostProjectsIdResponse(rsp *http.Response) (*PostProjectsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePutProjectsIdResponse parses an HTTP response from a PutProjectsIdWithResponse call
func ParsePutProjectsIdResponse(rsp *http.Response) (*PutProjectsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all customers
	// (GET /customers)
	GetCustomers(ctx echo.Context, params GetCustomersParams) error
	// Remove a customer
	// (DELETE /customers/{id})
	DeleteCustomersId(ctx echo.Context, id string) error
	// Get a customer by ID
	// (GET /customers/{id})
	GetCustomersId(ctx echo.Context, id string) error
	// Add a customer
	// (POST /customers/{id})
	PostCustomersId(ctx echo.Context, id string) error
	// Update a customer
	// (PUT /customers/{id})
	PutCustomersId(ctx echo.Context, id string) error
	// Get all employees
	// (GET /employees)
	GetEmployees(ctx echo.Context, params GetEmployeesParams) error
	// Get all Expenses
	// (GET /expenses)
	GetExpenses(ctx echo.Context, params GetExpensesParams) error
	// Remove a Expense
	// (DELETE /expenses/{id})
	DeleteExpensesId(ctx echo.Context, id string) error
	// Get a Expense by ID
	// (GET /expenses/{id})
	GetExpensesId(ctx echo.Context, id string) error
	// Add a Expense
	// (POST /expenses/{id})
	PostExpensesId(ctx echo.Context, id string) error
	// Update a Expense
	// (PUT /expenses/{id})
	PutExpensesId(ctx echo.Context, id string) error
	// Get all invoices
	// (GET /invoices)
	GetInvoices(ctx echo.Context, params GetInvoicesParams) error
	// Remove a Invoice
	// (DELETE /invoices/{id})
	DeleteInvoicesId(ctx echo.Context, id string) error
	// Get a Invoice by ID
	// (GET /invoices/{id})
	GetInvoicesId(ctx echo.Context, id string) error
	// Add a Invoice
	// (POST /invoices/{id})
	PostInvoicesId(ctx echo.Context, id string) error
	// Update a Invoice
	// (PUT /invoices/{id})
	PutInvoicesId(ctx echo.Context, id string) error
	// Get all Miscellaneous Records
	// (GET /misc_records)
	GetMiscRecords(ctx echo.Context, params GetMiscRecordsParams) error
	// Remove a Miscellaneous Record
	// (DELETE /misc_records/{id})
	DeleteMiscRecordsId(ctx echo.Context, id string) error
	// Get a Miscellaneous Record by ID
	// (GET /misc_records/{id})
	GetMiscRecordsId(ctx echo.Context, id string) error
	// Add a Miscellaneous Record
	// (POST /misc_records/{id})
	PostMiscRecordsId(ctx echo.Context, id string) error
	// Update a Miscellaneous Record
	// (PUT /misc_records/{id})
	PutMiscRecordsId(ctx echo.Context, id string) error
	// Get all Projects
	// (GET /projects)
	GetProjects(ctx echo.Context, params GetProjectsParams) error
	// Remove a Project
	// (DELETE /projects/{id})
	DeleteProjectsId(ctx echo.Context, id string) error
	// Get a Project by ID
	// (GET /projects/{id})
	GetProjectsId(ctx echo.Context, id string) error
	// Add a Project
	// (POST /projects/{id})
	PostProjectsId(ctx echo.Context, id string) error
	// Update a Project
	// (PUT /projects/{id})
	PutProjectsId(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetCustomers converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomers(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomersParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomers(ctx, params)
	return err
}

// DeleteCustomersId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCustomersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCustomersId(ctx, id)
	return err
}

// GetCustomersId converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomersId(ctx, id)
	return err
}

// PostCustomersId converts echo context to params.
func (w *ServerInterfaceWrapper) PostCustomersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCustomersId(ctx, id)
	return err
}

// PutCustomersId converts echo context to params.
func (w *ServerInterfaceWrapper) PutCustomersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutCustomersId(ctx, id)
	return err
}

// GetEmployees converts echo context to params.
func (w *ServerInterfaceWrapper) GetEmployees(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEmployeesParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEmployees(ctx, params)
	return err
}

// GetExpenses converts echo context to params.
func (w *ServerInterfaceWrapper) GetExpenses(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExpensesParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExpenses(ctx, params)
	return err
}

// DeleteExpensesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteExpensesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteExpensesId(ctx, id)
	return err
}

// GetExpensesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetExpensesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExpensesId(ctx, id)
	return err
}

// PostExpensesId converts echo context to params.
func (w *ServerInterfaceWrapper) PostExpensesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostExpensesId(ctx, id)
	return err
}

// PutExpensesId converts echo context to params.
func (w *ServerInterfaceWrapper) PutExpensesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutExpensesId(ctx, id)
	return err
}

// GetInvoices converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvoices(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvoicesParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetInvoices(ctx, params)
	return err
}

// DeleteInvoicesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteInvoicesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteInvoicesId(ctx, id)
	return err
}

// GetInvoicesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvoicesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetInvoicesId(ctx, id)
	return err
}

// PostInvoicesId converts echo context to params.
func (w *ServerInterfaceWrapper) PostInvoicesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostInvoicesId(ctx, id)
	return err
}

// PutInvoicesId converts echo context to params.
func (w *ServerInterfaceWrapper) PutInvoicesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutInvoicesId(ctx, id)
	return err
}

// GetMiscRecords converts echo context to params.
func (w *ServerInterfaceWrapper) GetMiscRecords(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMiscRecordsParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMiscRecords(ctx, params)
	return err
}

// DeleteMiscRecordsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteMiscRecordsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteMiscRecordsId(ctx, id)
	return err
}

// GetMiscRecordsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetMiscRecordsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMiscRecordsId(ctx, id)
	return err
}

// PostMiscRecordsId converts echo context to params.
func (w *ServerInterfaceWrapper) PostMiscRecordsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostMiscRecordsId(ctx, id)
	return err
}

// PutMiscRecordsId converts echo context to params.
func (w *ServerInterfaceWrapper) PutMiscRecordsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutMiscRecordsId(ctx, id)
	return err
}

// GetProjects converts echo context to params.
func (w *ServerInterfaceWrapper) GetProjects(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProjectsParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProjects(ctx, params)
	return err
}

// DeleteProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteProjectsId(ctx, id)
	return err
}

// GetProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProjectsId(ctx, id)
	return err
}

// PostProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) PostProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProjectsId(ctx, id)
	return err
}

// PutProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) PutProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutProjectsId(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/customers", wrapper.GetCustomers)
	router.DELETE(baseURL+"/customers/:id", wrapper.DeleteCustomersId)
	router.GET(baseURL+"/customers/:id", wrapper.GetCustomersId)
	router.POST(baseURL+"/customers/:id", wrapper.PostCustomersId)
	router.PUT(baseURL+"/customers/:id", wrapper.PutCustomersId)
	router.GET(baseURL+"/employees", wrapper.GetEmployees)
	router.GET(baseURL+"/expenses", wrapper.GetExpenses)
	router.DELETE(baseURL+"/expenses/:id", wrapper.DeleteExpensesId)
	router.GET(baseURL+"/expenses/:id", wrapper.GetExpensesId)
	router.POST(baseURL+"/expenses/:id", wrapper.PostExpensesId)
	router.PUT(baseURL+"/expenses/:id", wrapper.PutExpensesId)
	router.GET(baseURL+"/invoices", wrapper.GetInvoices)
	router.DELETE(baseURL+"/invoices/:id", wrapper.DeleteInvoicesId)
	router.GET(baseURL+"/invoices/:id", wrapper.GetInvoicesId)
	router.POST(baseURL+"/invoices/:id", wrapper.PostInvoicesId)
	router.PUT(baseURL+"/invoices/:id", wrapper.PutInvoicesId)
	router.GET(baseURL+"/misc_records", wrapper.GetMiscRecords)
	router.DELETE(baseURL+"/misc_records/:id", wrapper.DeleteMiscRecordsId)
	router.GET(baseURL+"/misc_records/:id", wrapper.GetMiscRecordsId)
	router.POST(baseURL+"/misc_records/:id", wrapper.PostMiscRecordsId)
	router.PUT(baseURL+"/misc_records/:id", wrapper.PutMiscRecordsId)
	router.GET(baseURL+"/projects", wrapper.GetProjects)
	router.DELETE(baseURL+"/projects/:id", wrapper.DeleteProjectsId)
	router.GET(baseURL+"/projects/:id", wrapper.GetProjectsId)
	router.POST(baseURL+"/projects/:id", wrapper.PostProjectsId)
	router.PUT(baseURL+"/projects/:id", wrapper.PutProjectsId)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xdfW/cNpP/KgP1gKc57Jvf8mKgwLl22hq49IwkxSFP7XvAlUa7bCRSJSk7G2O/2f13",
	"X+xAUtTLLne966xdpyFQoFlLHA6Hw99vOBxJt9GYSLwgahodR8PrvagXxTwvOEOmZHR8O+9FlKU8Or6N",
	"Ys4UiZX+J+aEZtFxlMvJf6Ri8mJ/EPM86kWM5BgdRy/2WRL1olLoe6ZKFfJ4OJxQNS3H+sahuT7vRQnK",
	"WNBCUc6i4+j9lEo4uTgHZGScoQTFoZQIaopQZISyvsJPCl6/vQDFeQYncQzXlABh8Pb1u/dpmQFlCkVK",
	"YhxEvSijMTKJWt9Krzfn75fU4gUyyUsR44CLybBqJIf63nkvUlRluunJ6anpxSh4xuMyR6aI0bwXXaOQ",
	"dgyjwdFgX7fLeYKZNLb6VDg1uuN9bS+AwEKg1PYGAgWZacmQcIYwnpnB6wkhbAZcAAE1pSKBggg10wYi",
	"UpbC2oizCadsAjw1P8elpAyljHpRIXiBQlE0CpHkmrAYkx9n77WsCy1qWbt3iiiUcDNFNcXFjr/HvMj4",
	"DLEHqOLBM3Ay7WRVYzCKUAluoCkX7fFEvUjNCm3cMecZEqbt5gQ1qp0ny8q9xRSFcRAtr63ZzZTGU686",
	"US/CTyQvzHTO+ofPm/6lEpRNTPc5L5nydVjNkZlyPTIC9l7975wznA3g1M6hQCBFgSzBBIieU3XDIaET",
	"qoCV+RgFSCyIIAoTPcMEEq4G8H6KcE2yEmFKzMjGLTE3VE2roQpEiKdEkFihgLgUAlk8g5gnxumbIe4f",
	"jAaH+3D6y0/aA4hSKPRI/ufyMvn3y8vB5WVyuz+/vJS/n/Q/X90ezP/NZ48xzTK9GO/0DzuvUsl6lt2s",
	"39As04NJubghQo+mmra4lIrnKLx+kBCF/5WexLEoSbbc+wnoG4AyK4lk2k7C/U65yImCDx8+fOi/edM/",
	"O+saZrR32B8d9fcPlgxzezjvW8NU//Maxer2DpXK0HjW01KvApxTonDChWdpn2ZESprOOtNEmUYTVv+O",
	"q+baM6kETQJaa+39VGpcNvM4QYbak42oDJMJCkCmBMUlRxjAr1zRGI+Nqy920/J6/ESl0vhBGZA47nr1",
	"T5wnvkFTD0r89tv5mUNDPv4DY2X1doqVjGrkJhnQBJmiKY2b5c0Aq9ltd39wgIQ8f4H9g/39o/5hsof9",
	"V8/30/5BfJgmycvxwfPRvl892wEKj5qM/lmiVk304ymXyKC53ShLnLl6IKe8zBJtpmmZEwYCSWIWaFtL",
	"7D9/5dVC0yPzrael1dyCbWqnkjBw7aEoRcElakZiXA28K9hy7mJHZ+bXGCXkSBhlE03bOWEMO87SGc4v",
	"J/8Jr0ajkW9IfJzRCSanFZbcTRYOdSqmmJJr1JcKMlvZf9zfO/L1XRCa/DdV0zMcU7URQtaYSCQkVGCs",
	"shloMQ3C58S6veGWREv+0vYQE5H456gwcd/tUiCGkJZZBvqys5sLJ0BgzEUCSRUDwfcXZz9pR7j49edn",
	"HbMNdfOh4sMKkAZFknrNKLhem3dPHZGSx9TwZtVm4JMna2B+LwiTJNbC1ksnUHAp6ThDGBP2EVTTsPIT",
	"KzTpzMLKeMbpMq//YuGnhc7SRxoxzzKMHQTlZaZokdX96UiOKsxlCCVDKBlCyRBKhlAyhJIhlAyhZAgl",
	"v81QsvoDEYLM7Jq85jRGH4ec20ug4w6rpXPewXJQFwKXjhPE2wOC/uFMrhdYZfbBIha8+Apjgr85PVbT",
	"tiE90v7+S58WdzFWy0G6TvGBl8Jd8RPFbmF24MfZCkoeC2cFXvOP6JVmLjiLWGRJqNQTkWjXYRwyznSs",
	"qMhHZFXsaTnLT1QSWXJGFD6xZfXgVOPwaIFqug6g+nu+AMXHPpWLbJPIcLO4OpERmCowVWCqwFSBqQJT",
	"7YypFvdJOZXxW+Npyzr/2HVF6bLAAoFxBY70tFO6TD6MSwVS0SwDmhdcKMKUXaJ2cimbDOC1VfwYTiAW",
	"mGh24QohFTy36RBZCsLsGuuSXPL0POBLkesNlTFmGWHISwl2KuSGOJb390ab49ivJEcH975euz71C5JM",
	"TZvJgMbVHwPh/ACnvbVvm60CufusSAbc/JVkntWoIwEqZYkJlAW3PkWEoNckW2tNaOxNJVR+PAMqIacy",
	"Q5JQNgHCkjqTH08Jm2Bi8rOQlqoUCFU11b2Xe7O8t4lNvT65OlANOBFwIuDEV40Ti2FBQZq1tBlmVC3g",
	"e7edsuu9OtCWz9btc1sn8QUKyVkjpS3kWWVpc26m/5M81zu1GQjM8JrYTXI3ddzFhb/5Lsgc7G+ICXH/",
	"6H6QYGdo2Ji4kfmGfII3pVQocsKYf/kLNXtv/npnZYStPKCylfawtRrOHwYwgh/gdV0zsQc/wGkrQYKs",
	"zKPj30e9vauWlqNaLcoUTlAYvTIS3zVuc0t7uP/8v/8VNJ56x8mlItkpTzxC/3l+Mbww1/v6BiefJImw",
	"dSV1Dy9HI6+2UglEtV5de09VqaENKVBqh4k1AXaG8Y7HFNUM3lmpPqw0V34VvkkzvVTZIZ7avv4hfaM5",
	"fLU8lk2xaBZgI8BGgI0AG6tho8pU+YDiwl6q3F0WGOvl2Jn07oK/Z/K4UsE4X5NC82SQj77BFG01CQ+N",
	"MxdNwrKRdvLRGIVhiSD5Z0r0JpeIj+qGCiXjKUnVZnFyNcPbBMYXrsmaADg4aHDQ3ThoN3ia9yJeICMF",
	"1XYdjAYjm72YGica1ls1/WuC3tNDVQom9VSdaJFm2rIMmk1efcBnt8ba7f4sUZiyr1wPUrstcZvr6GdU",
	"p3WvhthJjsqo8LsvK2CPCZXb4Or+T+IYEo6S/UOBLIuCCwUSiYineqes4zu3fhrpQI1fSrNj/vx5VjUA",
	"fq1jhiwDklzb8wlIKWaJNDtuUY9+BjlRtoN66HpwVOtpxts88el+yniKOdE2XZq3JT602mg/XLAsaTpu",
	"HLYqHnXqcZbNAD+RWDU3VwtLwveMd4d8MyVKcrxG8WzVCForad0wrnqRQFlwV8K/Pxq5Z2OrA1BSFFm1",
	"4Id/SD3U25a8kFkIW4SwRQhbhL8oszBfeur+JMs8OK9bHllo695+7uq236HQPPJaCG57lmWeEzGzfNcl",
	"TG0FMtF0Vwdx0ZVu07Dx8JYmc9tdhvYgo0uiZ+bvNY+eJ1GDxC0gXng8wXm6lZqALOMYpUzLLJsN9CAP",
	"R4eemee151tGqtgVEzg/g5SXLBncw0It4mBllrVN9hZzfo2ttek3Wc9FLKsDjI5hdkRRgU8CnwQ+CXzi",
	"5Y8Gsh4ZThcIp3HD8QzOz1YB6MLuqzH0y/H+6Gh8kPYPDuJR//DF0cs+efFy1H+V7scv9/ZexSR97vYO",
	"5kS3tXUwkPtnSQUm0bESJd6xhdAOuAzj2u0WcfzPEqX6kSezrwXCA0YGjPzWMXLuj8AWVmWSbByQniSm",
	"IqJG0ZTQDL8QNE+SZIN4syh9QFUGnAo4FXDqm8Cp34qE/OVb5wa2rDp3Ite8Fw3rdOnWqf665T1S/a/r",
	"Xr/KVH899IdJ9S9YNqT6Q6o/pGYCnQc6f+xUf0OOu0j1Y4v0HBu7vzk2br347C4yJm0ydq8/q0DMlaNn",
	"FWnZFwUbRDM47yfl5hVq4fg9HL+HN+6FN+6FN+6FN+6FN+6FN+6FN+6FN+6FN+6FN+7do9J4/Q6rDiJ3",
	"scFqRaT1/qry9u72asNCKidvszoqZ7Sty6iaOOJRq6gaIFg21uoaKq9NdrDNCHuFsFcIe4WwVwh7hbBX",
	"CHuFsFcIe4W//17BVyjrYtDHjZcXy2RdF4tVsu0I+YkXyS4E6ruoPQsxeojRQ4weYvQQo+8kRg9BcAiC",
	"QxAcguCHehKiVmpnD0KsTxmvegwiRKIhEg2RaIhEQyQaItEQiYZINESiX3UkuvWzbg+ar60fdVsXm857",
	"0bD9Ka6tSuvrzxR8QWl966NeobQ+lNaHb8CFb8CFb8CFb8CFb8CFb8A92W/A3VG5W3PULip3aUN4Lnpz",
	"H+ruRm8bVu465Tar3HV23LpytyaEx63cbYHJkrFWV+56bbKTKCaEIiEUCaFICEVCKBJCkZ2EIr7CQOe2",
	"j0vHi4WBrovFwsA2AT/xwsCFOGA3L6ULIUAIAZ7IB1EDxwaODRz7F9Yd1XrurO5o/YZ3Vd1RILpAdIHo",
	"AtEFogtE9wBlDQ+626zLGtZR37wXmS/a/8sum+1LG3zfnf+iOgctsBITSh1CqcMGpQ5eF1xd9/Bjlymc",
	"s2qsZVw1tTpcuCdJJYxLBVLRLAOaa38irPqgqsVeyiYDeG1x5RhOIBaY6OiKK4RU8NwWF8pSEGYpsBvk",
	"JU8PoL80sPDOyYZhRt7fG93v1b++XruQ/wuSTE2byYCGiR4jAPHHHxqA+7bZqhjkPoTJagD2kKWOhKmU",
	"JSZQFtz6FBGCXpNsrTWhsTeVUPmxeQtyTmWGxGzfNDa6wvN4StgEE1NODGmpSoEOrB/nlNkPD7s4cl4F",
	"PI5mW8TqodoNz6FbfLjZUbRPq+3Ppb1SHvmQ2qfDSvOuPrVeZcEdcFLgksAlgUu+Yi7xHRNqE/6V0Lh4",
	"YOjtb/H0cBEMn/gJ4jIm7yK3GuA4wHGA468ajh/qRMkLors7XtoyVF113hRgMcBigMUAi490/vB4kWx9",
	"GLEVUM570bA6Sdv+ZOKiavglhxFORjiJCCcRG5xEtNxl5UOX1T0Va9QOcLqyBOSeJQ/VujHfp2vOpT11",
	"D0ffYBF9NQkP/SnCi6YKoJF28tEYhWGJIPlnSjKEN0R8VDdUKBlPSaoeIAteu+YuEt8tP3fAXbnbAmhv",
	"mON28jZLcLsVtHVO2zV85DR21a3XWKuz1l6b7AS8AgIFBNoFAvlyp86zH3cVLmZMXReLSdL2unviCdKF",
	"5b+bytOvZeWHpfVgebDaBXaW+lpPb6syXcG/g3/vPqHxoNxS5zDWebxpoh0UzYWpUoWMruo7bx1XtF6/",
	"uLDB5jlyhnAz5TAuZxKkKtPUJlVnvBRNKavenFfS6m9Ar5N2w8VH+667GS+7zesXX614yuBh3o3a0YHW",
	"VaqemSFuTo0FXMK6076dOeo9uQR4S9Gi9p4VwVO1zJuHQlqNpSLKBbGLzU1ZdH0DaBQllGm7t5KhEjgD",
	"Yu+tK8eXXeFfOU8wW+rku+++qz+Rd8kuy9HoIH5n4PgMU8qoAQeLz28x/eEy+m5oBMn6u3mXEQxNO7xk",
	"l6wl717i2tI8zrRmFK7Gfrtunacsj6KSdy9xq0bRcuk1I/EePGynR94cOy2PzCf/vuJXjdSAxpoxXhBD",
	"2dt1W1SNlkZkXmy8vazZSu3tul2nfxXtbNmpa7U8AnvlXuJWjaJGjmocrUst/HAXr3rRp74ik58FL4sO",
	"s51cnLeYscVzLZJqCKeB/S6ANyjZQN5VS6U3ZkzLr2qsJ2ERAnyLqet2i9O4aJCexw5X86v5/wcAAP//",
	"b7ROntzZAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

