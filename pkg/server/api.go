// Package Merged provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package Merged

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// GetCustomersParams defines parameters for GetCustomers.
type GetCustomersParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching customers.
	Query *string `json:"query,omitempty"`

	// Search for customers with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// PostCustomersIdJSONBody defines parameters for PostCustomersId.
type PostCustomersIdJSONBody struct {

	// Unique user-chosen identifier for a Party, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the person/company
	Name *string `json:"name,omitempty"`

	// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
	PartyType *int `json:"partyType,omitempty"`

	// Name of the place
	Place *string `json:"place,omitempty"`

	// ZIP/Postal-Code of the address
	PostalCode *int `json:"postalCode,omitempty"`

	// Name of the street the party residence in
	Street *string `json:"street,omitempty"`

	// Street number of party's address
	StreetNr *int `json:"streetNr,omitempty"`
}

// PutCustomersIdJSONBody defines parameters for PutCustomersId.
type PutCustomersIdJSONBody struct {

	// Unique user-chosen identifier for a Party, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the person/company
	Name *string `json:"name,omitempty"`

	// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
	PartyType *int `json:"partyType,omitempty"`

	// Name of the place
	Place *string `json:"place,omitempty"`

	// ZIP/Postal-Code of the address
	PostalCode *int `json:"postalCode,omitempty"`

	// Name of the street the party residence in
	Street *string `json:"street,omitempty"`

	// Street number of party's address
	StreetNr *int `json:"streetNr,omitempty"`
}

// GetEmployeesParams defines parameters for GetEmployees.
type GetEmployeesParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching employees.
	Query *string `json:"query,omitempty"`

	// Search for employees with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// GetExpensesParams defines parameters for GetExpenses.
type GetExpensesParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching customers.
	Query *string `json:"query,omitempty"`

	// Search for customers with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// PostExpensesIdJSONBody defines parameters for PostExpensesId.
type PostExpensesIdJSONBody struct {

	// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
	AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

	// Refers to the third party which advanced the payment
	AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

	// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
	Amount *string `json:"amount,omitempty"`

	// States whether the costs for the Expense will be forwarded to the customer
	Billable *bool `json:"billable,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

	// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
	ExpenseCategory *string `json:"expenseCategory,omitempty"`

	// Unique user-chosen identifier for a Expense, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// States whether this Expense is for an internal purpose or not.
	Internal *bool `json:"internal,omitempty"`

	// Describes meaningful manner the Expense
	Name *string `json:"name,omitempty"`

	// Refers to the customer which have to pay the Expense
	ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

	// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
	PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

	// The full path to the business record document (PDF or PNG)
	Path *string `json:"path,omitempty"`

	// Refers to the associated project.
	ProjectId *string `json:"projectId,omitempty"`

	// Refers to a possible bank transaction which settled the Expense for the company
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// PutExpensesIdJSONBody defines parameters for PutExpensesId.
type PutExpensesIdJSONBody struct {

	// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
	AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

	// Refers to the third party which advanced the payment
	AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

	// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
	Amount *string `json:"amount,omitempty"`

	// States whether the costs for the Expense will be forwarded to the customer
	Billable *bool `json:"billable,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

	// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
	ExpenseCategory *string `json:"expenseCategory,omitempty"`

	// Unique user-chosen identifier for a Expense, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// States whether this Expense is for an internal purpose or not.
	Internal *bool `json:"internal,omitempty"`

	// Describes meaningful manner the Expense
	Name *string `json:"name,omitempty"`

	// Refers to the customer which have to pay the Expense
	ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

	// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
	PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

	// The full path to the business record document (PDF or PNG)
	Path *string `json:"path,omitempty"`

	// Refers to the associated project.
	ProjectId *string `json:"projectId,omitempty"`

	// Refers to a possible bank transaction which settled the Expense for the company
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// GetInvoicesParams defines parameters for GetInvoices.
type GetInvoicesParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching customers.
	Query *string `json:"query,omitempty"`

	// Search for customers with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// PostInvoicesIdJSONBody defines parameters for PostInvoicesId.
type PostInvoicesIdJSONBody struct {

	// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
	Amount *string `json:"amount,omitempty"`

	// Refers to the customer the Invoice was sent to.
	CustomerId *string `json:"customerId,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

	// Unique user-chosen identifier for a Invoice, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Describes the Invoice.
	Name *string `json:"name,omitempty"`

	// The full path to the business record document (PDF or PNG).
	Path *string `json:"path,omitempty"`

	// Refers to the associated project.
	ProjectId *string `json:"projectId,omitempty"`

	// Revoked Invoices are disabled an no longer taken into account.
	Revoked *bool `json:"revoked,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	SendDate *string `json:"sendDate,omitempty"`

	// Refers to a possible bank transaction which settled the Invoice for the company.
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// PutInvoicesIdJSONBody defines parameters for PutInvoicesId.
type PutInvoicesIdJSONBody struct {

	// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
	Amount *string `json:"amount,omitempty"`

	// Refers to the customer the Invoice was sent to.
	CustomerId *string `json:"customerId,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

	// Unique user-chosen identifier for a Invoice, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Describes the Invoice.
	Name *string `json:"name,omitempty"`

	// The full path to the business record document (PDF or PNG).
	Path *string `json:"path,omitempty"`

	// Refers to the associated project.
	ProjectId *string `json:"projectId,omitempty"`

	// Revoked Invoices are disabled an no longer taken into account.
	Revoked *bool `json:"revoked,omitempty"`

	// A date in the calender in the format YYYY-MM-DD
	SendDate *string `json:"sendDate,omitempty"`

	// Refers to a possible bank transaction which settled the Invoice for the company.
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// GetMiscRecordsParams defines parameters for GetMiscRecords.
type GetMiscRecordsParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching customers.
	Query *string `json:"query,omitempty"`

	// Search for customers with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// PostMiscRecordsIdJSONBody defines parameters for PostMiscRecordsId.
type PostMiscRecordsIdJSONBody struct {

	// A date in the calender in the format YYYY-MM-DD
	Date *string `json:"date,omitempty"`

	// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the Miscellaneous Record.
	Name *string `json:"name,omitempty"`

	// The full path to the business record document (PDF or PNG)
	Path *string `json:"path,omitempty"`

	// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// PutMiscRecordsIdJSONBody defines parameters for PutMiscRecordsId.
type PutMiscRecordsIdJSONBody struct {

	// A date in the calender in the format YYYY-MM-DD
	Date *string `json:"date,omitempty"`

	// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the Miscellaneous Record.
	Name *string `json:"name,omitempty"`

	// The full path to the business record document (PDF or PNG)
	Path *string `json:"path,omitempty"`

	// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
	SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
}

// GetProjectsParams defines parameters for GetProjects.
type GetProjectsParams struct {

	// The current version of Acc doesn't support searching in specific parameters it uses a fuzzy search over all advisable fields and returns any matching customers.
	Query *string `json:"query,omitempty"`

	// Search for customers with a matching identifier. This returns only exact matching elements (no fuzzy search whatsoever).
	Identifier *string `json:"identifier,omitempty"`
}

// PostProjectsIdJSONBody defines parameters for PostProjectsId.
type PostProjectsIdJSONBody struct {

	// Refers to the customer the project is associated to.
	CustomerId *string `json:"customerId,omitempty"`

	// Unique user-chosen identifier for a Project, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the Project.
	Name *string `json:"name,omitempty"`
}

// PutProjectsIdJSONBody defines parameters for PutProjectsId.
type PutProjectsIdJSONBody struct {

	// Refers to the customer the project is associated to.
	CustomerId *string `json:"customerId,omitempty"`

	// Unique user-chosen identifier for a Project, should be human readable
	Identifier *string `json:"identifier,omitempty"`

	// Name of the Project.
	Name *string `json:"name,omitempty"`
}

// PostCustomersIdRequestBody defines body for PostCustomersId for application/json ContentType.
type PostCustomersIdJSONRequestBody PostCustomersIdJSONBody

// PutCustomersIdRequestBody defines body for PutCustomersId for application/json ContentType.
type PutCustomersIdJSONRequestBody PutCustomersIdJSONBody

// PostExpensesIdRequestBody defines body for PostExpensesId for application/json ContentType.
type PostExpensesIdJSONRequestBody PostExpensesIdJSONBody

// PutExpensesIdRequestBody defines body for PutExpensesId for application/json ContentType.
type PutExpensesIdJSONRequestBody PutExpensesIdJSONBody

// PostInvoicesIdRequestBody defines body for PostInvoicesId for application/json ContentType.
type PostInvoicesIdJSONRequestBody PostInvoicesIdJSONBody

// PutInvoicesIdRequestBody defines body for PutInvoicesId for application/json ContentType.
type PutInvoicesIdJSONRequestBody PutInvoicesIdJSONBody

// PostMiscRecordsIdRequestBody defines body for PostMiscRecordsId for application/json ContentType.
type PostMiscRecordsIdJSONRequestBody PostMiscRecordsIdJSONBody

// PutMiscRecordsIdRequestBody defines body for PutMiscRecordsId for application/json ContentType.
type PutMiscRecordsIdJSONRequestBody PutMiscRecordsIdJSONBody

// PostProjectsIdRequestBody defines body for PostProjectsId for application/json ContentType.
type PostProjectsIdJSONRequestBody PostProjectsIdJSONBody

// PutProjectsIdRequestBody defines body for PutProjectsId for application/json ContentType.
type PutProjectsIdJSONRequestBody PutProjectsIdJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCustomers request
	GetCustomers(ctx context.Context, params *GetCustomersParams) (*http.Response, error)

	// DeleteCustomersId request
	DeleteCustomersId(ctx context.Context, id string) (*http.Response, error)

	// GetCustomersId request
	GetCustomersId(ctx context.Context, id string) (*http.Response, error)

	// PostCustomersId request  with any body
	PostCustomersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PostCustomersId(ctx context.Context, id string, body PostCustomersIdJSONRequestBody) (*http.Response, error)

	// PutCustomersId request  with any body
	PutCustomersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PutCustomersId(ctx context.Context, id string, body PutCustomersIdJSONRequestBody) (*http.Response, error)

	// GetEmployees request
	GetEmployees(ctx context.Context, params *GetEmployeesParams) (*http.Response, error)

	// GetExpenses request
	GetExpenses(ctx context.Context, params *GetExpensesParams) (*http.Response, error)

	// DeleteExpensesId request
	DeleteExpensesId(ctx context.Context, id string) (*http.Response, error)

	// GetExpensesId request
	GetExpensesId(ctx context.Context, id string) (*http.Response, error)

	// PostExpensesId request  with any body
	PostExpensesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PostExpensesId(ctx context.Context, id string, body PostExpensesIdJSONRequestBody) (*http.Response, error)

	// PutExpensesId request  with any body
	PutExpensesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PutExpensesId(ctx context.Context, id string, body PutExpensesIdJSONRequestBody) (*http.Response, error)

	// GetInvoices request
	GetInvoices(ctx context.Context, params *GetInvoicesParams) (*http.Response, error)

	// DeleteInvoicesId request
	DeleteInvoicesId(ctx context.Context, id string) (*http.Response, error)

	// GetInvoicesId request
	GetInvoicesId(ctx context.Context, id string) (*http.Response, error)

	// PostInvoicesId request  with any body
	PostInvoicesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PostInvoicesId(ctx context.Context, id string, body PostInvoicesIdJSONRequestBody) (*http.Response, error)

	// PutInvoicesId request  with any body
	PutInvoicesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PutInvoicesId(ctx context.Context, id string, body PutInvoicesIdJSONRequestBody) (*http.Response, error)

	// GetMiscRecords request
	GetMiscRecords(ctx context.Context, params *GetMiscRecordsParams) (*http.Response, error)

	// DeleteMiscRecordsId request
	DeleteMiscRecordsId(ctx context.Context, id string) (*http.Response, error)

	// GetMiscRecordsId request
	GetMiscRecordsId(ctx context.Context, id string) (*http.Response, error)

	// PostMiscRecordsId request  with any body
	PostMiscRecordsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PostMiscRecordsId(ctx context.Context, id string, body PostMiscRecordsIdJSONRequestBody) (*http.Response, error)

	// PutMiscRecordsId request  with any body
	PutMiscRecordsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PutMiscRecordsId(ctx context.Context, id string, body PutMiscRecordsIdJSONRequestBody) (*http.Response, error)

	// GetProjects request
	GetProjects(ctx context.Context, params *GetProjectsParams) (*http.Response, error)

	// DeleteProjectsId request
	DeleteProjectsId(ctx context.Context, id string) (*http.Response, error)

	// GetProjectsId request
	GetProjectsId(ctx context.Context, id string) (*http.Response, error)

	// PostProjectsId request  with any body
	PostProjectsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PostProjectsId(ctx context.Context, id string, body PostProjectsIdJSONRequestBody) (*http.Response, error)

	// PutProjectsId request  with any body
	PutProjectsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	PutProjectsId(ctx context.Context, id string, body PutProjectsIdJSONRequestBody) (*http.Response, error)
}

func (c *Client) GetCustomers(ctx context.Context, params *GetCustomersParams) (*http.Response, error) {
	req, err := NewGetCustomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomersId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeleteCustomersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomersId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetCustomersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostCustomersIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostCustomersId(ctx context.Context, id string, body PostCustomersIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPostCustomersIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutCustomersIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutCustomersIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutCustomersId(ctx context.Context, id string, body PutCustomersIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPutCustomersIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmployees(ctx context.Context, params *GetEmployeesParams) (*http.Response, error) {
	req, err := NewGetEmployeesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetExpenses(ctx context.Context, params *GetExpensesParams) (*http.Response, error) {
	req, err := NewGetExpensesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExpensesId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeleteExpensesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetExpensesId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetExpensesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostExpensesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostExpensesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostExpensesId(ctx context.Context, id string, body PostExpensesIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPostExpensesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutExpensesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutExpensesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutExpensesId(ctx context.Context, id string, body PutExpensesIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPutExpensesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoices(ctx context.Context, params *GetInvoicesParams) (*http.Response, error) {
	req, err := NewGetInvoicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInvoicesId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeleteInvoicesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoicesId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetInvoicesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvoicesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostInvoicesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostInvoicesId(ctx context.Context, id string, body PostInvoicesIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPostInvoicesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutInvoicesIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutInvoicesIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutInvoicesId(ctx context.Context, id string, body PutInvoicesIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPutInvoicesIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMiscRecords(ctx context.Context, params *GetMiscRecordsParams) (*http.Response, error) {
	req, err := NewGetMiscRecordsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMiscRecordsId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeleteMiscRecordsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMiscRecordsId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetMiscRecordsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostMiscRecordsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostMiscRecordsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostMiscRecordsId(ctx context.Context, id string, body PostMiscRecordsIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPostMiscRecordsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutMiscRecordsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutMiscRecordsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutMiscRecordsId(ctx context.Context, id string, body PutMiscRecordsIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPutMiscRecordsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjects(ctx context.Context, params *GetProjectsParams) (*http.Response, error) {
	req, err := NewGetProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProjectsId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewDeleteProjectsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProjectsId(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetProjectsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostProjectsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPostProjectsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PostProjectsId(ctx context.Context, id string, body PostProjectsIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPostProjectsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutProjectsIdWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewPutProjectsIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) PutProjectsId(ctx context.Context, id string, body PutProjectsIdJSONRequestBody) (*http.Response, error) {
	req, err := NewPutProjectsIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewGetCustomersRequest generates requests for GetCustomers
func NewGetCustomersRequest(server string, params *GetCustomersParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/customers")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCustomersIdRequest generates requests for DeleteCustomersId
func NewDeleteCustomersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/customers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomersIdRequest generates requests for GetCustomersId
func NewGetCustomersIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/customers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCustomersIdRequest calls the generic PostCustomersId builder with application/json body
func NewPostCustomersIdRequest(server string, id string, body PostCustomersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCustomersIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostCustomersIdRequestWithBody generates requests for PostCustomersId with any type of body
func NewPostCustomersIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/customers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPutCustomersIdRequest calls the generic PutCustomersId builder with application/json body
func NewPutCustomersIdRequest(server string, id string, body PutCustomersIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutCustomersIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutCustomersIdRequestWithBody generates requests for PutCustomersId with any type of body
func NewPutCustomersIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/customers/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetEmployeesRequest generates requests for GetEmployees
func NewGetEmployeesRequest(server string, params *GetEmployeesParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/employees")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExpensesRequest generates requests for GetExpenses
func NewGetExpensesRequest(server string, params *GetExpensesParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/expenses")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteExpensesIdRequest generates requests for DeleteExpensesId
func NewDeleteExpensesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/expenses/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExpensesIdRequest generates requests for GetExpensesId
func NewGetExpensesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/expenses/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExpensesIdRequest calls the generic PostExpensesId builder with application/json body
func NewPostExpensesIdRequest(server string, id string, body PostExpensesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExpensesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostExpensesIdRequestWithBody generates requests for PostExpensesId with any type of body
func NewPostExpensesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/expenses/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPutExpensesIdRequest calls the generic PutExpensesId builder with application/json body
func NewPutExpensesIdRequest(server string, id string, body PutExpensesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutExpensesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutExpensesIdRequestWithBody generates requests for PutExpensesId with any type of body
func NewPutExpensesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/expenses/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetInvoicesRequest generates requests for GetInvoices
func NewGetInvoicesRequest(server string, params *GetInvoicesParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/invoices")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteInvoicesIdRequest generates requests for DeleteInvoicesId
func NewDeleteInvoicesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/invoices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoicesIdRequest generates requests for GetInvoicesId
func NewGetInvoicesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/invoices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostInvoicesIdRequest calls the generic PostInvoicesId builder with application/json body
func NewPostInvoicesIdRequest(server string, id string, body PostInvoicesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostInvoicesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostInvoicesIdRequestWithBody generates requests for PostInvoicesId with any type of body
func NewPostInvoicesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/invoices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPutInvoicesIdRequest calls the generic PutInvoicesId builder with application/json body
func NewPutInvoicesIdRequest(server string, id string, body PutInvoicesIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutInvoicesIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutInvoicesIdRequestWithBody generates requests for PutInvoicesId with any type of body
func NewPutInvoicesIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/invoices/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetMiscRecordsRequest generates requests for GetMiscRecords
func NewGetMiscRecordsRequest(server string, params *GetMiscRecordsParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/misc_records")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMiscRecordsIdRequest generates requests for DeleteMiscRecordsId
func NewDeleteMiscRecordsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/misc_records/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMiscRecordsIdRequest generates requests for GetMiscRecordsId
func NewGetMiscRecordsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/misc_records/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMiscRecordsIdRequest calls the generic PostMiscRecordsId builder with application/json body
func NewPostMiscRecordsIdRequest(server string, id string, body PostMiscRecordsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMiscRecordsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostMiscRecordsIdRequestWithBody generates requests for PostMiscRecordsId with any type of body
func NewPostMiscRecordsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/misc_records/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPutMiscRecordsIdRequest calls the generic PutMiscRecordsId builder with application/json body
func NewPutMiscRecordsIdRequest(server string, id string, body PutMiscRecordsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutMiscRecordsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutMiscRecordsIdRequestWithBody generates requests for PutMiscRecordsId with any type of body
func NewPutMiscRecordsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/misc_records/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetProjectsRequest generates requests for GetProjects
func NewGetProjectsRequest(server string, params *GetProjectsParams) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	queryValues := queryUrl.Query()

	if params.Query != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "query", *params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Identifier != nil {

		if queryFrag, err := runtime.StyleParam("form", true, "identifier", *params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryUrl.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProjectsIdRequest generates requests for DeleteProjectsId
func NewDeleteProjectsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectsIdRequest generates requests for GetProjectsId
func NewGetProjectsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostProjectsIdRequest calls the generic PostProjectsId builder with application/json body
func NewPostProjectsIdRequest(server string, id string, body PostProjectsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostProjectsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPostProjectsIdRequestWithBody generates requests for PostProjectsId with any type of body
func NewPostProjectsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewPutProjectsIdRequest calls the generic PutProjectsId builder with application/json body
func NewPutProjectsIdRequest(server string, id string, body PutProjectsIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutProjectsIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutProjectsIdRequestWithBody generates requests for PutProjectsId with any type of body
func NewPutProjectsIdRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/projects/%s", pathParam0)
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCustomers request
	GetCustomersWithResponse(ctx context.Context, params *GetCustomersParams) (*GetCustomersResponse, error)

	// DeleteCustomersId request
	DeleteCustomersIdWithResponse(ctx context.Context, id string) (*DeleteCustomersIdResponse, error)

	// GetCustomersId request
	GetCustomersIdWithResponse(ctx context.Context, id string) (*GetCustomersIdResponse, error)

	// PostCustomersId request  with any body
	PostCustomersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostCustomersIdResponse, error)

	PostCustomersIdWithResponse(ctx context.Context, id string, body PostCustomersIdJSONRequestBody) (*PostCustomersIdResponse, error)

	// PutCustomersId request  with any body
	PutCustomersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutCustomersIdResponse, error)

	PutCustomersIdWithResponse(ctx context.Context, id string, body PutCustomersIdJSONRequestBody) (*PutCustomersIdResponse, error)

	// GetEmployees request
	GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams) (*GetEmployeesResponse, error)

	// GetExpenses request
	GetExpensesWithResponse(ctx context.Context, params *GetExpensesParams) (*GetExpensesResponse, error)

	// DeleteExpensesId request
	DeleteExpensesIdWithResponse(ctx context.Context, id string) (*DeleteExpensesIdResponse, error)

	// GetExpensesId request
	GetExpensesIdWithResponse(ctx context.Context, id string) (*GetExpensesIdResponse, error)

	// PostExpensesId request  with any body
	PostExpensesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostExpensesIdResponse, error)

	PostExpensesIdWithResponse(ctx context.Context, id string, body PostExpensesIdJSONRequestBody) (*PostExpensesIdResponse, error)

	// PutExpensesId request  with any body
	PutExpensesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutExpensesIdResponse, error)

	PutExpensesIdWithResponse(ctx context.Context, id string, body PutExpensesIdJSONRequestBody) (*PutExpensesIdResponse, error)

	// GetInvoices request
	GetInvoicesWithResponse(ctx context.Context, params *GetInvoicesParams) (*GetInvoicesResponse, error)

	// DeleteInvoicesId request
	DeleteInvoicesIdWithResponse(ctx context.Context, id string) (*DeleteInvoicesIdResponse, error)

	// GetInvoicesId request
	GetInvoicesIdWithResponse(ctx context.Context, id string) (*GetInvoicesIdResponse, error)

	// PostInvoicesId request  with any body
	PostInvoicesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostInvoicesIdResponse, error)

	PostInvoicesIdWithResponse(ctx context.Context, id string, body PostInvoicesIdJSONRequestBody) (*PostInvoicesIdResponse, error)

	// PutInvoicesId request  with any body
	PutInvoicesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutInvoicesIdResponse, error)

	PutInvoicesIdWithResponse(ctx context.Context, id string, body PutInvoicesIdJSONRequestBody) (*PutInvoicesIdResponse, error)

	// GetMiscRecords request
	GetMiscRecordsWithResponse(ctx context.Context, params *GetMiscRecordsParams) (*GetMiscRecordsResponse, error)

	// DeleteMiscRecordsId request
	DeleteMiscRecordsIdWithResponse(ctx context.Context, id string) (*DeleteMiscRecordsIdResponse, error)

	// GetMiscRecordsId request
	GetMiscRecordsIdWithResponse(ctx context.Context, id string) (*GetMiscRecordsIdResponse, error)

	// PostMiscRecordsId request  with any body
	PostMiscRecordsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostMiscRecordsIdResponse, error)

	PostMiscRecordsIdWithResponse(ctx context.Context, id string, body PostMiscRecordsIdJSONRequestBody) (*PostMiscRecordsIdResponse, error)

	// PutMiscRecordsId request  with any body
	PutMiscRecordsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutMiscRecordsIdResponse, error)

	PutMiscRecordsIdWithResponse(ctx context.Context, id string, body PutMiscRecordsIdJSONRequestBody) (*PutMiscRecordsIdResponse, error)

	// GetProjects request
	GetProjectsWithResponse(ctx context.Context, params *GetProjectsParams) (*GetProjectsResponse, error)

	// DeleteProjectsId request
	DeleteProjectsIdWithResponse(ctx context.Context, id string) (*DeleteProjectsIdResponse, error)

	// GetProjectsId request
	GetProjectsIdWithResponse(ctx context.Context, id string) (*GetProjectsIdResponse, error)

	// PostProjectsId request  with any body
	PostProjectsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostProjectsIdResponse, error)

	PostProjectsIdWithResponse(ctx context.Context, id string, body PostProjectsIdJSONRequestBody) (*PostProjectsIdResponse, error)

	// PutProjectsId request  with any body
	PutProjectsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutProjectsIdResponse, error)

	PutProjectsIdWithResponse(ctx context.Context, id string, body PutProjectsIdJSONRequestBody) (*PutProjectsIdResponse, error)
}

type GetCustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// Unique user-chosen identifier for a Party, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the person/company
		Name *string `json:"name,omitempty"`

		// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
		PartyType *int `json:"partyType,omitempty"`

		// Name of the place
		Place *string `json:"place,omitempty"`

		// ZIP/Postal-Code of the address
		PostalCode *int `json:"postalCode,omitempty"`

		// Name of the street the party residence in
		Street *string `json:"street,omitempty"`

		// Street number of party's address
		StreetNr *int `json:"streetNr,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// Unique user-chosen identifier for a Party, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the person/company
		Name *string `json:"name,omitempty"`

		// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
		PartyType *int `json:"partyType,omitempty"`

		// Name of the place
		Place *string `json:"place,omitempty"`

		// ZIP/Postal-Code of the address
		PostalCode *int `json:"postalCode,omitempty"`

		// Name of the street the party residence in
		Street *string `json:"street,omitempty"`

		// Street number of party's address
		StreetNr *int `json:"streetNr,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutCustomersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutCustomersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutCustomersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmployeesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// Unique user-chosen identifier for a Party, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the person/company
		Name *string `json:"name,omitempty"`

		// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
		PartyType *int `json:"partyType,omitempty"`

		// Name of the place
		Place *string `json:"place,omitempty"`

		// ZIP/Postal-Code of the address
		PostalCode *int `json:"postalCode,omitempty"`

		// Name of the street the party residence in
		Street *string `json:"street,omitempty"`

		// Street number of party's address
		StreetNr *int `json:"streetNr,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEmployeesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExpensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
		AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

		// Refers to the third party which advanced the payment
		AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

		// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
		Amount *string `json:"amount,omitempty"`

		// States whether the costs for the Expense will be forwarded to the customer
		Billable *bool `json:"billable,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

		// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
		ExpenseCategory *string `json:"expenseCategory,omitempty"`

		// Unique user-chosen identifier for a Expense, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// States whether this Expense is for an internal purpose or not.
		Internal *bool `json:"internal,omitempty"`

		// Describes meaningful manner the Expense
		Name *string `json:"name,omitempty"`

		// Refers to the customer which have to pay the Expense
		ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

		// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
		PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

		// The full path to the business record document (PDF or PNG)
		Path *string `json:"path,omitempty"`

		// Refers to the associated project.
		ProjectId *string `json:"projectId,omitempty"`

		// Refers to a possible bank transaction which settled the Expense for the company
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetExpensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExpensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExpensesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteExpensesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExpensesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExpensesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
		AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

		// Refers to the third party which advanced the payment
		AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

		// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
		Amount *string `json:"amount,omitempty"`

		// States whether the costs for the Expense will be forwarded to the customer
		Billable *bool `json:"billable,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

		// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
		ExpenseCategory *string `json:"expenseCategory,omitempty"`

		// Unique user-chosen identifier for a Expense, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// States whether this Expense is for an internal purpose or not.
		Internal *bool `json:"internal,omitempty"`

		// Describes meaningful manner the Expense
		Name *string `json:"name,omitempty"`

		// Refers to the customer which have to pay the Expense
		ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

		// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
		PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

		// The full path to the business record document (PDF or PNG)
		Path *string `json:"path,omitempty"`

		// Refers to the associated project.
		ProjectId *string `json:"projectId,omitempty"`

		// Refers to a possible bank transaction which settled the Expense for the company
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetExpensesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExpensesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExpensesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostExpensesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExpensesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutExpensesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutExpensesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutExpensesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
		Amount *string `json:"amount,omitempty"`

		// Refers to the customer the Invoice was sent to.
		CustomerId *string `json:"customerId,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

		// Unique user-chosen identifier for a Invoice, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Describes the Invoice.
		Name *string `json:"name,omitempty"`

		// The full path to the business record document (PDF or PNG).
		Path *string `json:"path,omitempty"`

		// Refers to the associated project.
		ProjectId *string `json:"projectId,omitempty"`

		// Revoked Invoices are disabled an no longer taken into account.
		Revoked *bool `json:"revoked,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		SendDate *string `json:"sendDate,omitempty"`

		// Refers to a possible bank transaction which settled the Invoice for the company.
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInvoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInvoicesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInvoicesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInvoicesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
		Amount *string `json:"amount,omitempty"`

		// Refers to the customer the Invoice was sent to.
		CustomerId *string `json:"customerId,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

		// Unique user-chosen identifier for a Invoice, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Describes the Invoice.
		Name *string `json:"name,omitempty"`

		// The full path to the business record document (PDF or PNG).
		Path *string `json:"path,omitempty"`

		// Refers to the associated project.
		ProjectId *string `json:"projectId,omitempty"`

		// Revoked Invoices are disabled an no longer taken into account.
		Revoked *bool `json:"revoked,omitempty"`

		// A date in the calender in the format YYYY-MM-DD
		SendDate *string `json:"sendDate,omitempty"`

		// Refers to a possible bank transaction which settled the Invoice for the company.
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetInvoicesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostInvoicesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostInvoicesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostInvoicesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutInvoicesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutInvoicesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutInvoicesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMiscRecordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// A date in the calender in the format YYYY-MM-DD
		Date *string `json:"date,omitempty"`

		// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the Miscellaneous Record.
		Name *string `json:"name,omitempty"`

		// The full path to the business record document (PDF or PNG)
		Path *string `json:"path,omitempty"`

		// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMiscRecordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMiscRecordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMiscRecordsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMiscRecordsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMiscRecordsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMiscRecordsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// A date in the calender in the format YYYY-MM-DD
		Date *string `json:"date,omitempty"`

		// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the Miscellaneous Record.
		Name *string `json:"name,omitempty"`

		// The full path to the business record document (PDF or PNG)
		Path *string `json:"path,omitempty"`

		// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
		SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMiscRecordsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMiscRecordsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMiscRecordsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostMiscRecordsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMiscRecordsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutMiscRecordsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutMiscRecordsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutMiscRecordsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// Refers to the customer the project is associated to.
		CustomerId *string `json:"customerId,omitempty"`

		// Unique user-chosen identifier for a Project, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the Project.
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Embedded fields due to inline allOf schema

		// UUID of the object used for the universal identification of an element
		Id *string `json:"id,omitempty"`
		// Embedded fields due to inline allOf schema

		// Refers to the customer the project is associated to.
		CustomerId *string `json:"customerId,omitempty"`

		// Unique user-chosen identifier for a Project, should be human readable
		Identifier *string `json:"identifier,omitempty"`

		// Name of the Project.
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutProjectsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PutProjectsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutProjectsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCustomersWithResponse request returning *GetCustomersResponse
func (c *ClientWithResponses) GetCustomersWithResponse(ctx context.Context, params *GetCustomersParams) (*GetCustomersResponse, error) {
	rsp, err := c.GetCustomers(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomersResponse(rsp)
}

// DeleteCustomersIdWithResponse request returning *DeleteCustomersIdResponse
func (c *ClientWithResponses) DeleteCustomersIdWithResponse(ctx context.Context, id string) (*DeleteCustomersIdResponse, error) {
	rsp, err := c.DeleteCustomersId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomersIdResponse(rsp)
}

// GetCustomersIdWithResponse request returning *GetCustomersIdResponse
func (c *ClientWithResponses) GetCustomersIdWithResponse(ctx context.Context, id string) (*GetCustomersIdResponse, error) {
	rsp, err := c.GetCustomersId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomersIdResponse(rsp)
}

// PostCustomersIdWithBodyWithResponse request with arbitrary body returning *PostCustomersIdResponse
func (c *ClientWithResponses) PostCustomersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostCustomersIdResponse, error) {
	rsp, err := c.PostCustomersIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersIdResponse(rsp)
}

func (c *ClientWithResponses) PostCustomersIdWithResponse(ctx context.Context, id string, body PostCustomersIdJSONRequestBody) (*PostCustomersIdResponse, error) {
	rsp, err := c.PostCustomersId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostCustomersIdResponse(rsp)
}

// PutCustomersIdWithBodyWithResponse request with arbitrary body returning *PutCustomersIdResponse
func (c *ClientWithResponses) PutCustomersIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutCustomersIdResponse, error) {
	rsp, err := c.PutCustomersIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutCustomersIdResponse(rsp)
}

func (c *ClientWithResponses) PutCustomersIdWithResponse(ctx context.Context, id string, body PutCustomersIdJSONRequestBody) (*PutCustomersIdResponse, error) {
	rsp, err := c.PutCustomersId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePutCustomersIdResponse(rsp)
}

// GetEmployeesWithResponse request returning *GetEmployeesResponse
func (c *ClientWithResponses) GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams) (*GetEmployeesResponse, error) {
	rsp, err := c.GetEmployees(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetEmployeesResponse(rsp)
}

// GetExpensesWithResponse request returning *GetExpensesResponse
func (c *ClientWithResponses) GetExpensesWithResponse(ctx context.Context, params *GetExpensesParams) (*GetExpensesResponse, error) {
	rsp, err := c.GetExpenses(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetExpensesResponse(rsp)
}

// DeleteExpensesIdWithResponse request returning *DeleteExpensesIdResponse
func (c *ClientWithResponses) DeleteExpensesIdWithResponse(ctx context.Context, id string) (*DeleteExpensesIdResponse, error) {
	rsp, err := c.DeleteExpensesId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExpensesIdResponse(rsp)
}

// GetExpensesIdWithResponse request returning *GetExpensesIdResponse
func (c *ClientWithResponses) GetExpensesIdWithResponse(ctx context.Context, id string) (*GetExpensesIdResponse, error) {
	rsp, err := c.GetExpensesId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetExpensesIdResponse(rsp)
}

// PostExpensesIdWithBodyWithResponse request with arbitrary body returning *PostExpensesIdResponse
func (c *ClientWithResponses) PostExpensesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostExpensesIdResponse, error) {
	rsp, err := c.PostExpensesIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostExpensesIdResponse(rsp)
}

func (c *ClientWithResponses) PostExpensesIdWithResponse(ctx context.Context, id string, body PostExpensesIdJSONRequestBody) (*PostExpensesIdResponse, error) {
	rsp, err := c.PostExpensesId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostExpensesIdResponse(rsp)
}

// PutExpensesIdWithBodyWithResponse request with arbitrary body returning *PutExpensesIdResponse
func (c *ClientWithResponses) PutExpensesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutExpensesIdResponse, error) {
	rsp, err := c.PutExpensesIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutExpensesIdResponse(rsp)
}

func (c *ClientWithResponses) PutExpensesIdWithResponse(ctx context.Context, id string, body PutExpensesIdJSONRequestBody) (*PutExpensesIdResponse, error) {
	rsp, err := c.PutExpensesId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePutExpensesIdResponse(rsp)
}

// GetInvoicesWithResponse request returning *GetInvoicesResponse
func (c *ClientWithResponses) GetInvoicesWithResponse(ctx context.Context, params *GetInvoicesParams) (*GetInvoicesResponse, error) {
	rsp, err := c.GetInvoices(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesResponse(rsp)
}

// DeleteInvoicesIdWithResponse request returning *DeleteInvoicesIdResponse
func (c *ClientWithResponses) DeleteInvoicesIdWithResponse(ctx context.Context, id string) (*DeleteInvoicesIdResponse, error) {
	rsp, err := c.DeleteInvoicesId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInvoicesIdResponse(rsp)
}

// GetInvoicesIdWithResponse request returning *GetInvoicesIdResponse
func (c *ClientWithResponses) GetInvoicesIdWithResponse(ctx context.Context, id string) (*GetInvoicesIdResponse, error) {
	rsp, err := c.GetInvoicesId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesIdResponse(rsp)
}

// PostInvoicesIdWithBodyWithResponse request with arbitrary body returning *PostInvoicesIdResponse
func (c *ClientWithResponses) PostInvoicesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostInvoicesIdResponse, error) {
	rsp, err := c.PostInvoicesIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostInvoicesIdResponse(rsp)
}

func (c *ClientWithResponses) PostInvoicesIdWithResponse(ctx context.Context, id string, body PostInvoicesIdJSONRequestBody) (*PostInvoicesIdResponse, error) {
	rsp, err := c.PostInvoicesId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostInvoicesIdResponse(rsp)
}

// PutInvoicesIdWithBodyWithResponse request with arbitrary body returning *PutInvoicesIdResponse
func (c *ClientWithResponses) PutInvoicesIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutInvoicesIdResponse, error) {
	rsp, err := c.PutInvoicesIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutInvoicesIdResponse(rsp)
}

func (c *ClientWithResponses) PutInvoicesIdWithResponse(ctx context.Context, id string, body PutInvoicesIdJSONRequestBody) (*PutInvoicesIdResponse, error) {
	rsp, err := c.PutInvoicesId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePutInvoicesIdResponse(rsp)
}

// GetMiscRecordsWithResponse request returning *GetMiscRecordsResponse
func (c *ClientWithResponses) GetMiscRecordsWithResponse(ctx context.Context, params *GetMiscRecordsParams) (*GetMiscRecordsResponse, error) {
	rsp, err := c.GetMiscRecords(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetMiscRecordsResponse(rsp)
}

// DeleteMiscRecordsIdWithResponse request returning *DeleteMiscRecordsIdResponse
func (c *ClientWithResponses) DeleteMiscRecordsIdWithResponse(ctx context.Context, id string) (*DeleteMiscRecordsIdResponse, error) {
	rsp, err := c.DeleteMiscRecordsId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMiscRecordsIdResponse(rsp)
}

// GetMiscRecordsIdWithResponse request returning *GetMiscRecordsIdResponse
func (c *ClientWithResponses) GetMiscRecordsIdWithResponse(ctx context.Context, id string) (*GetMiscRecordsIdResponse, error) {
	rsp, err := c.GetMiscRecordsId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetMiscRecordsIdResponse(rsp)
}

// PostMiscRecordsIdWithBodyWithResponse request with arbitrary body returning *PostMiscRecordsIdResponse
func (c *ClientWithResponses) PostMiscRecordsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostMiscRecordsIdResponse, error) {
	rsp, err := c.PostMiscRecordsIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostMiscRecordsIdResponse(rsp)
}

func (c *ClientWithResponses) PostMiscRecordsIdWithResponse(ctx context.Context, id string, body PostMiscRecordsIdJSONRequestBody) (*PostMiscRecordsIdResponse, error) {
	rsp, err := c.PostMiscRecordsId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostMiscRecordsIdResponse(rsp)
}

// PutMiscRecordsIdWithBodyWithResponse request with arbitrary body returning *PutMiscRecordsIdResponse
func (c *ClientWithResponses) PutMiscRecordsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutMiscRecordsIdResponse, error) {
	rsp, err := c.PutMiscRecordsIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutMiscRecordsIdResponse(rsp)
}

func (c *ClientWithResponses) PutMiscRecordsIdWithResponse(ctx context.Context, id string, body PutMiscRecordsIdJSONRequestBody) (*PutMiscRecordsIdResponse, error) {
	rsp, err := c.PutMiscRecordsId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePutMiscRecordsIdResponse(rsp)
}

// GetProjectsWithResponse request returning *GetProjectsResponse
func (c *ClientWithResponses) GetProjectsWithResponse(ctx context.Context, params *GetProjectsParams) (*GetProjectsResponse, error) {
	rsp, err := c.GetProjects(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsResponse(rsp)
}

// DeleteProjectsIdWithResponse request returning *DeleteProjectsIdResponse
func (c *ClientWithResponses) DeleteProjectsIdWithResponse(ctx context.Context, id string) (*DeleteProjectsIdResponse, error) {
	rsp, err := c.DeleteProjectsId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProjectsIdResponse(rsp)
}

// GetProjectsIdWithResponse request returning *GetProjectsIdResponse
func (c *ClientWithResponses) GetProjectsIdWithResponse(ctx context.Context, id string) (*GetProjectsIdResponse, error) {
	rsp, err := c.GetProjectsId(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectsIdResponse(rsp)
}

// PostProjectsIdWithBodyWithResponse request with arbitrary body returning *PostProjectsIdResponse
func (c *ClientWithResponses) PostProjectsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PostProjectsIdResponse, error) {
	rsp, err := c.PostProjectsIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePostProjectsIdResponse(rsp)
}

func (c *ClientWithResponses) PostProjectsIdWithResponse(ctx context.Context, id string, body PostProjectsIdJSONRequestBody) (*PostProjectsIdResponse, error) {
	rsp, err := c.PostProjectsId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePostProjectsIdResponse(rsp)
}

// PutProjectsIdWithBodyWithResponse request with arbitrary body returning *PutProjectsIdResponse
func (c *ClientWithResponses) PutProjectsIdWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*PutProjectsIdResponse, error) {
	rsp, err := c.PutProjectsIdWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsePutProjectsIdResponse(rsp)
}

func (c *ClientWithResponses) PutProjectsIdWithResponse(ctx context.Context, id string, body PutProjectsIdJSONRequestBody) (*PutProjectsIdResponse, error) {
	rsp, err := c.PutProjectsId(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParsePutProjectsIdResponse(rsp)
}

// ParseGetCustomersResponse parses an HTTP response from a GetCustomersWithResponse call
func ParseGetCustomersResponse(rsp *http.Response) (*GetCustomersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// Unique user-chosen identifier for a Party, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the person/company
			Name *string `json:"name,omitempty"`

			// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
			PartyType *int `json:"partyType,omitempty"`

			// Name of the place
			Place *string `json:"place,omitempty"`

			// ZIP/Postal-Code of the address
			PostalCode *int `json:"postalCode,omitempty"`

			// Name of the street the party residence in
			Street *string `json:"street,omitempty"`

			// Street number of party's address
			StreetNr *int `json:"streetNr,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomersIdResponse parses an HTTP response from a DeleteCustomersIdWithResponse call
func ParseDeleteCustomersIdResponse(rsp *http.Response) (*DeleteCustomersIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetCustomersIdResponse parses an HTTP response from a GetCustomersIdWithResponse call
func ParseGetCustomersIdResponse(rsp *http.Response) (*GetCustomersIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// Unique user-chosen identifier for a Party, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the person/company
			Name *string `json:"name,omitempty"`

			// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
			PartyType *int `json:"partyType,omitempty"`

			// Name of the place
			Place *string `json:"place,omitempty"`

			// ZIP/Postal-Code of the address
			PostalCode *int `json:"postalCode,omitempty"`

			// Name of the street the party residence in
			Street *string `json:"street,omitempty"`

			// Street number of party's address
			StreetNr *int `json:"streetNr,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCustomersIdResponse parses an HTTP response from a PostCustomersIdWithResponse call
func ParsePostCustomersIdResponse(rsp *http.Response) (*PostCustomersIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePutCustomersIdResponse parses an HTTP response from a PutCustomersIdWithResponse call
func ParsePutCustomersIdResponse(rsp *http.Response) (*PutCustomersIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutCustomersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetEmployeesResponse parses an HTTP response from a GetEmployeesWithResponse call
func ParseGetEmployeesResponse(rsp *http.Response) (*GetEmployeesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetEmployeesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// Unique user-chosen identifier for a Party, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the person/company
			Name *string `json:"name,omitempty"`

			// States whether a party is a customer or a employee. 0 = Employee, 1 = Customer.
			PartyType *int `json:"partyType,omitempty"`

			// Name of the place
			Place *string `json:"place,omitempty"`

			// ZIP/Postal-Code of the address
			PostalCode *int `json:"postalCode,omitempty"`

			// Name of the street the party residence in
			Street *string `json:"street,omitempty"`

			// Street number of party's address
			StreetNr *int `json:"streetNr,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExpensesResponse parses an HTTP response from a GetExpensesWithResponse call
func ParseGetExpensesResponse(rsp *http.Response) (*GetExpensesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetExpensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
			AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

			// Refers to the third party which advanced the payment
			AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

			// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
			Amount *string `json:"amount,omitempty"`

			// States whether the costs for the Expense will be forwarded to the customer
			Billable *bool `json:"billable,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

			// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
			ExpenseCategory *string `json:"expenseCategory,omitempty"`

			// Unique user-chosen identifier for a Expense, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// States whether this Expense is for an internal purpose or not.
			Internal *bool `json:"internal,omitempty"`

			// Describes meaningful manner the Expense
			Name *string `json:"name,omitempty"`

			// Refers to the customer which have to pay the Expense
			ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

			// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
			PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

			// The full path to the business record document (PDF or PNG)
			Path *string `json:"path,omitempty"`

			// Refers to the associated project.
			ProjectId *string `json:"projectId,omitempty"`

			// Refers to a possible bank transaction which settled the Expense for the company
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteExpensesIdResponse parses an HTTP response from a DeleteExpensesIdWithResponse call
func ParseDeleteExpensesIdResponse(rsp *http.Response) (*DeleteExpensesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteExpensesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetExpensesIdResponse parses an HTTP response from a GetExpensesIdWithResponse call
func ParseGetExpensesIdResponse(rsp *http.Response) (*GetExpensesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetExpensesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// States whether a third party (employee, etc.) advanced the payment of this Expense for the company
			AdvancedByThirdParty *bool `json:"advancedByThirdParty,omitempty"`

			// Refers to the third party which advanced the payment
			AdvancedThirdPartyId *string `json:"advancedThirdPartyId,omitempty"`

			// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
			Amount *string `json:"amount,omitempty"`

			// States whether the costs for the Expense will be forwarded to the customer
			Billable *bool `json:"billable,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfAccrual *string `json:"dateOfAccrual,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

			// Classify the Expense into an Expense category. This information is used to generate the ledger entries for the Expense. Notice: The Expense category has to be existent in acc.
			ExpenseCategory *string `json:"expenseCategory,omitempty"`

			// Unique user-chosen identifier for a Expense, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// States whether this Expense is for an internal purpose or not.
			Internal *bool `json:"internal,omitempty"`

			// Describes meaningful manner the Expense
			Name *string `json:"name,omitempty"`

			// Refers to the customer which have to pay the Expense
			ObligedCustomerId *string `json:"obligedCustomerId,omitempty"`

			// States whether the Expense was directly paid with the main account debithether the Expense was directly paid with the main account debit card.
			PaidWithDebit *bool `json:"paidWithDebit,omitempty"`

			// The full path to the business record document (PDF or PNG)
			Path *string `json:"path,omitempty"`

			// Refers to the associated project.
			ProjectId *string `json:"projectId,omitempty"`

			// Refers to a possible bank transaction which settled the Expense for the company
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostExpensesIdResponse parses an HTTP response from a PostExpensesIdWithResponse call
func ParsePostExpensesIdResponse(rsp *http.Response) (*PostExpensesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostExpensesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePutExpensesIdResponse parses an HTTP response from a PutExpensesIdWithResponse call
func ParsePutExpensesIdResponse(rsp *http.Response) (*PutExpensesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutExpensesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetInvoicesResponse parses an HTTP response from a GetInvoicesWithResponse call
func ParseGetInvoicesResponse(rsp *http.Response) (*GetInvoicesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
			Amount *string `json:"amount,omitempty"`

			// Refers to the customer the Invoice was sent to.
			CustomerId *string `json:"customerId,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

			// Unique user-chosen identifier for a Invoice, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Describes the Invoice.
			Name *string `json:"name,omitempty"`

			// The full path to the business record document (PDF or PNG).
			Path *string `json:"path,omitempty"`

			// Refers to the associated project.
			ProjectId *string `json:"projectId,omitempty"`

			// Revoked Invoices are disabled an no longer taken into account.
			Revoked *bool `json:"revoked,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			SendDate *string `json:"sendDate,omitempty"`

			// Refers to a possible bank transaction which settled the Invoice for the company.
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteInvoicesIdResponse parses an HTTP response from a DeleteInvoicesIdWithResponse call
func ParseDeleteInvoicesIdResponse(rsp *http.Response) (*DeleteInvoicesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteInvoicesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetInvoicesIdResponse parses an HTTP response from a GetInvoicesIdWithResponse call
func ParseGetInvoicesIdResponse(rsp *http.Response) (*GetInvoicesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// Representation of a amount of money. Cents are appended as a two digit number separated by a dot. The value has to be appended with the three character currency code.
			Amount *string `json:"amount,omitempty"`

			// Refers to the customer the Invoice was sent to.
			CustomerId *string `json:"customerId,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			DateOfSettlement *string `json:"dateOfSettlement,omitempty"`

			// Unique user-chosen identifier for a Invoice, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Describes the Invoice.
			Name *string `json:"name,omitempty"`

			// The full path to the business record document (PDF or PNG).
			Path *string `json:"path,omitempty"`

			// Refers to the associated project.
			ProjectId *string `json:"projectId,omitempty"`

			// Revoked Invoices are disabled an no longer taken into account.
			Revoked *bool `json:"revoked,omitempty"`

			// A date in the calender in the format YYYY-MM-DD
			SendDate *string `json:"sendDate,omitempty"`

			// Refers to a possible bank transaction which settled the Invoice for the company.
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostInvoicesIdResponse parses an HTTP response from a PostInvoicesIdWithResponse call
func ParsePostInvoicesIdResponse(rsp *http.Response) (*PostInvoicesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostInvoicesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePutInvoicesIdResponse parses an HTTP response from a PutInvoicesIdWithResponse call
func ParsePutInvoicesIdResponse(rsp *http.Response) (*PutInvoicesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutInvoicesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetMiscRecordsResponse parses an HTTP response from a GetMiscRecordsWithResponse call
func ParseGetMiscRecordsResponse(rsp *http.Response) (*GetMiscRecordsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMiscRecordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// A date in the calender in the format YYYY-MM-DD
			Date *string `json:"date,omitempty"`

			// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the Miscellaneous Record.
			Name *string `json:"name,omitempty"`

			// The full path to the business record document (PDF or PNG)
			Path *string `json:"path,omitempty"`

			// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteMiscRecordsIdResponse parses an HTTP response from a DeleteMiscRecordsIdWithResponse call
func ParseDeleteMiscRecordsIdResponse(rsp *http.Response) (*DeleteMiscRecordsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteMiscRecordsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetMiscRecordsIdResponse parses an HTTP response from a GetMiscRecordsIdWithResponse call
func ParseGetMiscRecordsIdResponse(rsp *http.Response) (*GetMiscRecordsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMiscRecordsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// A date in the calender in the format YYYY-MM-DD
			Date *string `json:"date,omitempty"`

			// Unique user-chosen identifier for a Miscellaneous Records, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the Miscellaneous Record.
			Name *string `json:"name,omitempty"`

			// The full path to the business record document (PDF or PNG)
			Path *string `json:"path,omitempty"`

			// Refers to an optional transaction which was issued upon the arrival of the Miscellaneous Record. Name of this property is misleading and will be changed in a future version.
			SettlementTransactionId *string `json:"settlementTransactionId,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostMiscRecordsIdResponse parses an HTTP response from a PostMiscRecordsIdWithResponse call
func ParsePostMiscRecordsIdResponse(rsp *http.Response) (*PostMiscRecordsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostMiscRecordsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePutMiscRecordsIdResponse parses an HTTP response from a PutMiscRecordsIdWithResponse call
func ParsePutMiscRecordsIdResponse(rsp *http.Response) (*PutMiscRecordsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutMiscRecordsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetProjectsResponse parses an HTTP response from a GetProjectsWithResponse call
func ParseGetProjectsResponse(rsp *http.Response) (*GetProjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// Refers to the customer the project is associated to.
			CustomerId *string `json:"customerId,omitempty"`

			// Unique user-chosen identifier for a Project, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the Project.
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteProjectsIdResponse parses an HTTP response from a DeleteProjectsIdWithResponse call
func ParseDeleteProjectsIdResponse(rsp *http.Response) (*DeleteProjectsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParseGetProjectsIdResponse parses an HTTP response from a GetProjectsIdWithResponse call
func ParseGetProjectsIdResponse(rsp *http.Response) (*GetProjectsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Embedded fields due to inline allOf schema

			// UUID of the object used for the universal identification of an element
			Id *string `json:"id,omitempty"`
			// Embedded fields due to inline allOf schema

			// Refers to the customer the project is associated to.
			CustomerId *string `json:"customerId,omitempty"`

			// Unique user-chosen identifier for a Project, should be human readable
			Identifier *string `json:"identifier,omitempty"`

			// Name of the Project.
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostProjectsIdResponse parses an HTTP response from a PostProjectsIdWithResponse call
func ParsePostProjectsIdResponse(rsp *http.Response) (*PostProjectsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PostProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ParsePutProjectsIdResponse parses an HTTP response from a PutProjectsIdWithResponse call
func ParsePutProjectsIdResponse(rsp *http.Response) (*PutProjectsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &PutProjectsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all customers
	// (GET /customers)
	GetCustomers(ctx echo.Context, params GetCustomersParams) error
	// Remove a customer
	// (DELETE /customers/{id})
	DeleteCustomersId(ctx echo.Context, id string) error
	// Get a customer by ID
	// (GET /customers/{id})
	GetCustomersId(ctx echo.Context, id string) error
	// Add a customer
	// (POST /customers/{id})
	PostCustomersId(ctx echo.Context, id string) error
	// Update a customer
	// (PUT /customers/{id})
	PutCustomersId(ctx echo.Context, id string) error
	// Get all employees
	// (GET /employees)
	GetEmployees(ctx echo.Context, params GetEmployeesParams) error
	// Get all Expenses
	// (GET /expenses)
	GetExpenses(ctx echo.Context, params GetExpensesParams) error
	// Remove a Expense
	// (DELETE /expenses/{id})
	DeleteExpensesId(ctx echo.Context, id string) error
	// Get a Expense by ID
	// (GET /expenses/{id})
	GetExpensesId(ctx echo.Context, id string) error
	// Add a Expense
	// (POST /expenses/{id})
	PostExpensesId(ctx echo.Context, id string) error
	// Update a Expense
	// (PUT /expenses/{id})
	PutExpensesId(ctx echo.Context, id string) error
	// Get all invoices
	// (GET /invoices)
	GetInvoices(ctx echo.Context, params GetInvoicesParams) error
	// Remove a Invoice
	// (DELETE /invoices/{id})
	DeleteInvoicesId(ctx echo.Context, id string) error
	// Get a Invoice by ID
	// (GET /invoices/{id})
	GetInvoicesId(ctx echo.Context, id string) error
	// Add a Invoice
	// (POST /invoices/{id})
	PostInvoicesId(ctx echo.Context, id string) error
	// Update a Invoice
	// (PUT /invoices/{id})
	PutInvoicesId(ctx echo.Context, id string) error
	// Get all Miscellaneous Records
	// (GET /misc_records)
	GetMiscRecords(ctx echo.Context, params GetMiscRecordsParams) error
	// Remove a Miscellaneous Record
	// (DELETE /misc_records/{id})
	DeleteMiscRecordsId(ctx echo.Context, id string) error
	// Get a Miscellaneous Record by ID
	// (GET /misc_records/{id})
	GetMiscRecordsId(ctx echo.Context, id string) error
	// Add a Miscellaneous Record
	// (POST /misc_records/{id})
	PostMiscRecordsId(ctx echo.Context, id string) error
	// Update a Miscellaneous Record
	// (PUT /misc_records/{id})
	PutMiscRecordsId(ctx echo.Context, id string) error
	// Get all Projects
	// (GET /projects)
	GetProjects(ctx echo.Context, params GetProjectsParams) error
	// Remove a Project
	// (DELETE /projects/{id})
	DeleteProjectsId(ctx echo.Context, id string) error
	// Get a Project by ID
	// (GET /projects/{id})
	GetProjectsId(ctx echo.Context, id string) error
	// Add a Project
	// (POST /projects/{id})
	PostProjectsId(ctx echo.Context, id string) error
	// Update a Project
	// (PUT /projects/{id})
	PutProjectsId(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetCustomers converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomers(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomersParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomers(ctx, params)
	return err
}

// DeleteCustomersId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCustomersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCustomersId(ctx, id)
	return err
}

// GetCustomersId converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomersId(ctx, id)
	return err
}

// PostCustomersId converts echo context to params.
func (w *ServerInterfaceWrapper) PostCustomersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostCustomersId(ctx, id)
	return err
}

// PutCustomersId converts echo context to params.
func (w *ServerInterfaceWrapper) PutCustomersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutCustomersId(ctx, id)
	return err
}

// GetEmployees converts echo context to params.
func (w *ServerInterfaceWrapper) GetEmployees(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEmployeesParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEmployees(ctx, params)
	return err
}

// GetExpenses converts echo context to params.
func (w *ServerInterfaceWrapper) GetExpenses(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExpensesParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExpenses(ctx, params)
	return err
}

// DeleteExpensesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteExpensesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteExpensesId(ctx, id)
	return err
}

// GetExpensesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetExpensesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExpensesId(ctx, id)
	return err
}

// PostExpensesId converts echo context to params.
func (w *ServerInterfaceWrapper) PostExpensesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostExpensesId(ctx, id)
	return err
}

// PutExpensesId converts echo context to params.
func (w *ServerInterfaceWrapper) PutExpensesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutExpensesId(ctx, id)
	return err
}

// GetInvoices converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvoices(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetInvoicesParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetInvoices(ctx, params)
	return err
}

// DeleteInvoicesId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteInvoicesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteInvoicesId(ctx, id)
	return err
}

// GetInvoicesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetInvoicesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetInvoicesId(ctx, id)
	return err
}

// PostInvoicesId converts echo context to params.
func (w *ServerInterfaceWrapper) PostInvoicesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostInvoicesId(ctx, id)
	return err
}

// PutInvoicesId converts echo context to params.
func (w *ServerInterfaceWrapper) PutInvoicesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutInvoicesId(ctx, id)
	return err
}

// GetMiscRecords converts echo context to params.
func (w *ServerInterfaceWrapper) GetMiscRecords(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMiscRecordsParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMiscRecords(ctx, params)
	return err
}

// DeleteMiscRecordsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteMiscRecordsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteMiscRecordsId(ctx, id)
	return err
}

// GetMiscRecordsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetMiscRecordsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMiscRecordsId(ctx, id)
	return err
}

// PostMiscRecordsId converts echo context to params.
func (w *ServerInterfaceWrapper) PostMiscRecordsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostMiscRecordsId(ctx, id)
	return err
}

// PutMiscRecordsId converts echo context to params.
func (w *ServerInterfaceWrapper) PutMiscRecordsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutMiscRecordsId(ctx, id)
	return err
}

// GetProjects converts echo context to params.
func (w *ServerInterfaceWrapper) GetProjects(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProjectsParams
	// ------------- Optional query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, false, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "identifier" -------------

	err = runtime.BindQueryParameter("form", true, false, "identifier", ctx.QueryParams(), &params.Identifier)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter identifier: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProjects(ctx, params)
	return err
}

// DeleteProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteProjectsId(ctx, id)
	return err
}

// GetProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProjectsId(ctx, id)
	return err
}

// PostProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) PostProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostProjectsId(ctx, id)
	return err
}

// PutProjectsId converts echo context to params.
func (w *ServerInterfaceWrapper) PutProjectsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutProjectsId(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/customers", wrapper.GetCustomers)
	router.DELETE(baseURL+"/customers/:id", wrapper.DeleteCustomersId)
	router.GET(baseURL+"/customers/:id", wrapper.GetCustomersId)
	router.POST(baseURL+"/customers/:id", wrapper.PostCustomersId)
	router.PUT(baseURL+"/customers/:id", wrapper.PutCustomersId)
	router.GET(baseURL+"/employees", wrapper.GetEmployees)
	router.GET(baseURL+"/expenses", wrapper.GetExpenses)
	router.DELETE(baseURL+"/expenses/:id", wrapper.DeleteExpensesId)
	router.GET(baseURL+"/expenses/:id", wrapper.GetExpensesId)
	router.POST(baseURL+"/expenses/:id", wrapper.PostExpensesId)
	router.PUT(baseURL+"/expenses/:id", wrapper.PutExpensesId)
	router.GET(baseURL+"/invoices", wrapper.GetInvoices)
	router.DELETE(baseURL+"/invoices/:id", wrapper.DeleteInvoicesId)
	router.GET(baseURL+"/invoices/:id", wrapper.GetInvoicesId)
	router.POST(baseURL+"/invoices/:id", wrapper.PostInvoicesId)
	router.PUT(baseURL+"/invoices/:id", wrapper.PutInvoicesId)
	router.GET(baseURL+"/misc_records", wrapper.GetMiscRecords)
	router.DELETE(baseURL+"/misc_records/:id", wrapper.DeleteMiscRecordsId)
	router.GET(baseURL+"/misc_records/:id", wrapper.GetMiscRecordsId)
	router.POST(baseURL+"/misc_records/:id", wrapper.PostMiscRecordsId)
	router.PUT(baseURL+"/misc_records/:id", wrapper.PutMiscRecordsId)
	router.GET(baseURL+"/projects", wrapper.GetProjects)
	router.DELETE(baseURL+"/projects/:id", wrapper.DeleteProjectsId)
	router.GET(baseURL+"/projects/:id", wrapper.GetProjectsId)
	router.POST(baseURL+"/projects/:id", wrapper.PostProjectsId)
	router.PUT(baseURL+"/projects/:id", wrapper.PutProjectsId)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xde2/cOJL/KgXNATs59MuvPAwMcD12ZsbAedZIMjhkx74FWyp1c0ORCknZ6Rj9ze6/",
	"+2ILSqJezba77bbHTggsduKWSFYVi79fkVWSroMJUXhG9Cw4DIaXO0EvCEWSCo5cq+DwetELKI9FcHgd",
	"hIJrEmrzT0wIZcFhkKjpf8Vy+mp3EIok6AWcJBgcBq92eRT0gkyae2Zap+pwOJxSPcsm5sZhfn3RCyJU",
	"oaSppoIHh8GHGVUwPjsB5GTCUIEWkCkEPUNIGaG8r/GLhrfvzkALwWAchnBJCRAO796+/xBnDCjXKGMS",
	"4iDoBYyGyBUaeUu5Tk8+LIklUuRKZDLEgZDTYdlIDc29i16gqWam6fjoKB8lF/BYhFmCXJNc8l5wiVIV",
	"OowGB4Nd0y4RETKV2+pLasUgjP09Dg7/vA5SKVKUmmJ+C43M/7et8ccfJ8cg4lx7MfkXhtoYI4JYyPy3",
	"jFMzLGFAI+SaxjTMxTFtCAdkaCQMegF+IUma67C3h4S8fIX9vd3dg/5+tIP9Ny934/5euB9H0evJ3svR",
	"btAL9Dw1dystKZ8Gi0X1SyFGsOh1ZX1bqAgSU4nKeA4QSMncSACR4AiTeS60cS3C5yAkENAzKiNIidRz",
	"M9VEqUwWsy34VFA+tepPMkU5KhX0OnYj0SXhIUY/zz+Yvs5MV8uWfK+JRgVXM9Qz7A78IyYpE3PEHqAO",
	"By/A9lm4XalDLghVYBW1k1DqUxttIgRDwo0H2I5q0U4c0/wOY5S5q5v+mpJdzWg4c4rTmtR5f//l8qT1",
	"ApKIjGvXgOUc1d4Cxb3m34ngOB/AUTGHEoGkKfIIIyBmTvWVgIhOqQaeJROUoDAlkmiMzAwTiIQewIcZ",
	"wiVhGcKM5JpNGt1cUT0rVZWIEM6IJKFGCWEmJfJwDqGI8uVbq7i7Nxrs78LRb78YDyBaozSa/O/5efSf",
	"5+eD8/Poendxfq7+HPe/XlzvLf7DZY8JZczAyq3+Ucyr0qqaZTvrV5Qxo0ws5BWRRpty2sJMaZGgdPpB",
	"RDT+PR6HocwIWx59DOYGoLzoiTBjJ2n/joVMiIaPHz9+7J+e9o+P24YZ7ez3Rwf93b0lw1zvL/qFYcr/",
	"OI1SyPYetS7h4mmJV0LnEdE4FdKxtI8YUYrG89Y0UW7QhFd/h2Vz45lUgaEzI7XxfqoKUNUCpsjReHLe",
	"FcNoihKQa0lxyREG8LvQNMTD3NW7wzS8Hr9QpQ1+UA4kDNte/YsQkUtpC+coHaTA6ecMjcyyH86EQg71",
	"7bmYxMrTAzUTGYuMHLMsIRwkkihfAU0psP/yjVMKw6Tc5bBLy6WBi7SwFeFg20OayVQoNJDPhR44l0hB",
	"z92BjvO/JqggQcIpnxqGTwjn2JqNljq/jf8b3oxGI5dKYsLoFKOjcrHejsZ2WZdQPCOXaC6lZL5y/LC/",
	"c+AaOyU0+h+qZ8c4oXotCKpAhyiIqMRQszmYbmoITUjhVzl4R6bn+7aHkMjIPUdpHiJeL8VsCHHGGJjL",
	"1m6Wr0FiKGQEURkuwY9nx78YRzj7/dcXLbMNTfOhFsNyxQ/SKHaaUQoTgtw+dUQpEdKcmMo2A1d/qkK+",
	"D5JwRULT2c29E0iFUnTCECaEfwJdNyz9pOg0as3CyoBhdZR1UQOgcuFyKBjD0JJ4kjFNU1aNaIIlqjFR",
	"Pu70caePO33c6eNOH3f6uNPHnT7u9HHnrXFn+RORksyLVXkpaPhNn2GO4aRQEkyQUljcLsTBcgToo5yW",
	"Q4ebg5v5w5rcgEVp9kEX1149wwDivlxa2mVNLqX93dcuKW6jt8YMtK3+UWTSXnGzynYxeeAG5RJ1HguU",
	"JV6KT+jsLb9gLVIs3YgqMxGRASougAluIjdNPiEvI8GC4NysppBHx0TjE/PbB+clu+A7vNR2AN3fcUUz",
	"bqoqnWSTIxI7j9/DEYmnNU9rntY8rXlae1601t2BJVSF73Jf+5bZ6uf2slL2MFoicKHBcr1ZYDY1ApNM",
	"g9KUMaBJKqQmXBdwUzgq5dMBvC1EP4QxhBIjQ0VCI8RSJMWhkcok4QVetC0aPT1vvi8Kn1IVImOEo8gU",
	"FE6l1sTkpL8zWh+TfycJWtdzjdpeH78hYXpWTwbUy/Yx0NoN1mbd9YtmqwD7LujCQeS/EuZAFhM2UKUy",
	"jCBLReFTREp6SdiN1oTa3lRB6cdzoAoSqhiSiPIpEB5VCYVwRvgUo/yYGOJMZxKhrGW7B3TVULVJUO70",
	"yu8hQveY5zHPY94zx7xuuJaSejWth39lC/jR7iSLFV9WCagX38dhRaNQI0WpBK/t0TTHi9Jr8rSq+Z8S",
	"idluz0Eiw0tSnHS0Ex9dU90PUPLCijUBJOwf3A0/ChMMax3qPk/JFzjNlEaZEM7dWCH1/EP+662VKUXl",
	"B1WNw6GiVsYafAAj+AneVjUrO/ATHDWOkZBnSXD456i3c9GQclSJRbnGKcpcLkbC2/TOb2mq+4///z9J",
	"w5lTT6E0YUcicnT6j5Oz4Vl+vW9usP2TKJJFXU81wuvRyCmt0hJR3yxucU9ZKWMMKVEZhwkNW7bUeC9C",
	"inoO74teXcCaX/lduiYtH6U8QxNxMdbflEub/TfLuqwPXHOPMR5jPMZ4jNkSxpSnk982qpwVSpZLV6UY",
	"GoFaDtxW+Y65hdKY+UKqD4AdCYaDh9hHlVo+NCid1efZdW/jT/nscswQlPhKCUM4JfKTvqJSq3BGYr1u",
	"uF4acZP4/Mw2+S7icO/Nz8ib2zHcoheIFDlJqXGRwWgwKs5cZvk8Davtpflris5kr84kV8brxqbL3AMZ",
	"g3pjWuVjiw29mdnPGcq8PDExahrPIPZIIPgV9VE1ah40kAR1LsKfrrOMIqur7bbcjD8OQ4gEKv43DSpL",
	"UyE1KCQynJn9vQnOrIvWvQPNl5jK9/lfv87LBiAuTTzCGJDossh2QUyRRSo/J5CV9nNIiC4GqFQ3ylEj",
	"Z65v/cSz/VOFM0yIsenSzC1xbSGN8cSOZUk9cO2yZRWxFU9wNgf8QkJd31xihIIfuWirfDUjWgm8RPli",
	"lQaNtXSTGhe9QKJKhX0qZXc0ss+Gl/lqkqasxK7hv5RR9brRnz8N8TsVv1PxO5XncBqyWHpFxZgxBykY",
	"SQ8KHGzffmIfRniP0pDOWylFMbbKkoTIeUGObXY1diBTw41VUBVcmDY1dQ+vabQohmNY5GrajHuc/16R",
	"7kkU1LDdQO3OQy3W14teI1BZGKJSccbYfGCU3B/tO+ZeVL5f0FdJxRjByTHEIuPR4A4WarAMzxhrmuwd",
	"JuISG6vTbbKeDW9WRyMtw9yJzzz5ePLx5OPJ597k4yCbGt8eGXs77FQ74mQOJ8er0Lazr6tN/XqyOzqY",
	"7MX9vb1w1N9/dfC6T169HvXfxLvh652dNyGJX9pdSZ7hbmxKcnz+nFGJUXCoZYa3bE6MCy5jvnG8Luh/",
	"zlDpn0U0v+f+xaOkR0mPko+CkotOYLgikB1H0drR6zjKK0QqFI0JZXhP0BxH0RrBaZq5gCrzOOVxyuPU",
	"d4FTf6QR+cv32TVsFeLcilyLXjCsDmI3TiJULe+QRHhbjfoskwiV6g+TROhY1icRfBLBM79nfs/8TzqJ",
	"UDPpNpII2GBIS932N0vdjVcK3sbcpMnc9sWCJU7YWn5WMlzxvu4cNHJScDN4/XJCXwXgqwD8uyz9uyz9",
	"uyz9uyz9uyz9uyz9uyz9uyz9uyz9uywf+F2Wt2zHqohzG7uxRvhabcZKf2/vxdas57L9rVfOZc22cTVX",
	"TdWPWsxVQ8GysVaXcjlt4iu5/MbCbyz8xsJvLPzGwm8s/MbCbyz8xmLbGwtXva4NWB83uO5W69ohusW6",
	"zXD6idfqdqL6bZTA+TDYh8E+DPZhsA+DfRjsw2AfBvsweAth8MM9kFEJtbXnMW4+X171NIaPRH0k6iNR",
	"H4n6SNRHoj4S9ZGoj0SfdSS68SN3D3peWz1xd1NsuugFw+ZH7jYq2q++HnGPov3G5/J80b4v2vdfV/Rf",
	"V/RfV/RfV/RfV/RfV/w2vq54S01wRWjbqAmmNTvaUM9+XL8d6q1ZE2yFW68m2Fpy45rgCnMftya4ASdL",
	"xlpdE+y0ia8J9nGLj1t83OLjFh+3PNO4xVVyaB33cbm7W3Joh+iWHDbZ+omXHHaChu28dc+zrGdZz7Ke",
	"ZT3LPheWfbiKpkrOrVU03bw7XlXR5InOE50nOk90nug80T1AwcSD7jargombqG/RC4YJVeE/i2WzedHE",
	"KVUhMkY4ikzBu6KX+1RQmA7LbnwRhS+iWKOIwumC30NFxc9tzrPLzrAGF7quZxLSPm2rYJJpUJoyBjQx",
	"K4Pw8sO1BYtQPh3A20L0QxhDKDEycaLQCLEUSVGAqTJJeEHmbYtGT49q7hsiOb1rzYAp6e+M7vbqZdeo",
	"bfL6DQnTs3oyoObUxwil3JGUoZJ+0WxVNHUX6ucVlTho38T0VKkMI8hSUfgUkZJeEnajNaG2N1VQ+nH+",
	"FuqEKoYk34galLfF+eGM8ClGeck1xJnOJFraeaz0uhvqtpFrXwWiNmRoBAmOsGHNBHyD29fLwbuk2jwh",
	"7+zlkbPzLhlWmnd1un6VBX3G3vOi50XPi98KL7rSt8aIfyXMdxO5zvG6Wd0usD/xzO4yv2zjzNsDsgdk",
	"D8jPGJAfLtPnBNHtpf02DLtX5QE9LHpY9LDoYfGR8kKPF8lWSaKNgHLRC4ZlhnPzjNFZ2fA+SSLbh88Q",
	"+QzRGhmihrt8B4/ZltqW/Fe58tHKIqM7FtWUCJB/t7GufHBU1hw8BK+XWj70NzDP6kKOurfxp3x2OWYI",
	"SnylhCGcEvlJX1GpVTgjsX6Q4//Kj7dx4t9YFBblyxntIPyah/u2v/VO9q2TbnyYbxs+8vl9OazTWKuP",
	"65028Wf1Hq6eJ1y5TmXtMnjcJds9i7VDdI9fm4v0iR+9drBiO7XGfnE9k8X1cCdslQts7VDtZi5cdYbm",
	"/dv79/aPSh6UW6rTkZs8Pm9iHBTzCzOtUxVcVHdeW65ovMqzs3UXCQqOcDUTMMnmCpTO4rg4rp2LTNbF",
	"yyZ8KnurvlR+U29XQn4q3ps4F1m7efUStRXPlTzMe3ZbMtCqLtkxM8TOaW4BexTeat88k+o9uaP1hqBp",
	"5T0rgqdymdePATUaK020jce7zfNC+OoGMChKKDd2bxyzKhAcSHFv9azAsiv8MxERsqVBfvjhh+rbjOf8",
	"PBuN9sL3ORwfY0w5zcGhwOd3GP90HvwwzDtS1QcbzwMY5u3wnJ/zRn936q7Zm8OZbtDCPlWx2bDWU5a1",
	"KPu7U3ertGi49A2aOFMam8mR1AmtZc1c/d+1+1Wa5qBxg45nJKfszYZNy0ZLGuUvyd68r/lK6Yt1e5P8",
	"ZbSz4aC21bIGxZU7dbdKiwo5Sj0alxr4YS9e9IIvfU2mv0qRpS1mG5+dNJixwXMNkqoJp4b9NoDXKFlD",
	"3kVDpNNcp+XXflaT0IUA12Jqu113GrsG6TnscLG4WPw7AAD//2gWpzcJ4AAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

